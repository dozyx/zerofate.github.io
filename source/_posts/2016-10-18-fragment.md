---
title: Fragment - 基础
tags:
  - android
  - fragment
date: 2016-10-18 15:37:22
categories: 笔记
---

[Fragment](https://developer.android.com/reference/android/app/Fragment.html)

### Fragment ###

![Fragment的生命周期](https://ws1.sinaimg.cn/large/006tKfTcgy1fin9l3fenpj308t0njab8.jpg)



### FragmentTransaction常用事务方法

+ add(int containerViewId, Fragment fragment, String tag)

  添加一个fragment，fragment可以将自己的视图添加到activity的容器视图中。tag为fragment的标签，FragmentManager#findFragmentByTag(String)可通过该tag获得对应的fragment。

+ replace(int containerViewId, Fragment fragment, String tag)

  替换一个被添加到容器中的已存在fragment。本质上等同于先调用remove(...)再调用add(...)

+ remove(int containerViewId, Fragment fragment, String tag)

  移除一个已存在的fragment

+ int commit()

  安排事务的提交。提交并不会立即提交，而是安排在主线程上的工作完成（线程下一次处于ready状态）时。事务只能在activity保存其状态（用户离开Activity）之前提交。返回值为一个整型，如果调用了addToBackStack(String)将返回该事务在回退栈入口的标识，否则返回一个负数。

+ addToBackStack((String name)

  将事务添加到回退栈，==name表示此回退栈状态的名称，可以为null==。



addToBackStack的一些理解

[What is the meaning of addToBackStack with null parameter?](http://stackoverflow.com/questions/22984950/what-is-the-meaning-of-addtobackstack-with-null-parameter)

[Fragment Guide](https://developer.android.com/guide/components/fragments.html)

`public abstract FragmentTransaction addToBackStack(String name);`

==以下见解未验证==

+ name标识该次提交的事务，比如先提交事务A，再提交事务B，如果两次提交前都调用了addToBackStack，并且使用了同一个name，则在back stack中保存的只有事务B的操作。将name设null表示不需要主动访问该次提交的事务。
+ 每个Activity都会单独维护自己的back stack
+ 依次执行：事务A：add#1，replace#1，addToBackStack#1，commit#1；事务B：add#2，remove#2，addToBackStack#2，commit#2。点击返回键，将相当于重新执行事务A：add#1，replace#1，addToBackStack#1，commit#1，但fragment对象并没有重新创建，而是使用之前的。（如果activity中有多个视图容器，可能会调用多个add等操作）
+ commit前的一组更改（add、remove等）称为一次事务。

  > ​如果您没有在执行移除片段的事务时调用 addToBackStack()，则事务提交时该片段会被销毁，用户将无法回退到该片段。 不过，如果您在删除片段时调用了 addToBackStack()，则系统会停止该片段，并在用户回退时将其恢复。



