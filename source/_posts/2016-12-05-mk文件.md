---
title: mk 文件
tags:
  - mk
date: 2016-12-05 15:37:22
categories: 笔记
---

[百度百科 makefile](http://baike.baidu.com/link?url=mFkh9Yr1bNMugerH57vsZxqwaZ4zI9VxZrYAM0t9k1DOG3nJBtZCM6orNCrEHtMle2ZD16XW7O1UPIkiI9IEA4_U-_6bdhcj8938mJJZmnK)

[Makefile经典教程(掌握这些足够)](http://blog.csdn.net/ruglcc/article/details/7814546/)

[NDK Programmer's Guide](http://brian.io/android-ndk-r10c-docs/Programmers_Guide/html/md_3__key__topics__building__chapter_1-section_8__android_8mk.html)

[Google Android.mk](https://developer.android.google.cn/ndk/guides/android_mk.html)

[Android NDK Overview](https://android.googlesource.com/platform/development/+/donut-release/ndk/docs/OVERVIEW.TXT)

[Android.mk doc](https://android.googlesource.com/platform/ndk/+/4e159d95ebf23b5f72bb707b0cb1518ef96b3d03/docs/ANDROID-MK.TXT)

## mk文件

mk是makefile的文件扩展名。Makefile 文件**描述了整个工程的编译、连接等规则**，其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建哪些库文件以及如何创建这些库文件、如何最后产生我们想要的可执行文件。本质上，makefile是一个脚本，可以用来实现自动化编译。



## Android NDK

Android NDK是用于允许Android应用开发者将由C/C++源码文件编译出来的本地机器码嵌入到他们的应用包里的一套工具。

### 目的

Android虚拟机允许在应用源码中通过JNI方式调用以native code实现的方法，这也意味着：

+ 应用源码中需要以native关键字声明一个或多个方法来表示它们是通过native code实现的，如

  native byte[]  loadFile(String  filePath);

+ 必须提供一个包含这些方法实现的native共享库，该库将打包进应用的.apk中。这个库必须用标准的Unix约定`lib<something>.so`来命名，并且需要包含一个标准的JNI入口。如

  libFileLoader.so

+ 应用必须显示地加载该库。如，在应用启动时加载，需要在源码中添加如下代码：

  static {

  ​	System.loadLibrary("FileLoader");

  }

  > 注意此处并未使用lib前缀和‘.so’后缀



Android NDK作为Android SDK的补充，用于

+ 生成可以运行在基于ARM CPU的Android平台的JNI兼容共享库
+ 将生成的共享库复制到应用工程路径的正确位置，使其可以自动添加到最终已签名的apk中



### 非目的

NDK并不是编写运行在Android平台的通用native code的一种好方式（个人理解为在Android平台，ndk只是作为编写应用的一种补充，大多数情况还是需要使用java来实现）。

> 对JNI的良好理解是十分推荐的



### NDK开发实践

1. 运行build/host-setup.sh来配置NDK
2. 将native源码放在$PROJECT/jni/...目录
3. 编写$PROJECT/jni/Android.mk来描述NDK编译系统的源码
4. 编写apps/\<myapp>/Application.mk来描述应用和NDK编译系统需要的native源码
5. 在顶层NDK目录执行“make APP=\<myapp>”来编译native代码



## Android.mk

Android.mk文件被用来向编译系统描述源码：

+ 该文件是一个极小的GNU makefile碎片，可能被编译系统解析一次或多次。因此，声明在该文件中的变量应该尽可能最小化，并且不要设定任何解析中未定义的东西。

+ 文件语法允许将源码按照modules来分组，module是下面中的一个：

  + a static library
  + a shared library

  只有shared library会被安装/复制待应用包中，但static库可以用来生成shared library。

+ 编译系统处理了很多细节部分，如：我们并不需要列举头文件或者显式声明生成文件的依赖。



### “hello example”例子

==文件== 

> sources/helloworld/helloworld.c
>
> sources/helloworld/Android.mk

`helloworld.c`是一个简单JNI共享库的源码，它实现了一个返回“hello world”字符串的native方法。

相应的Android.mk文件将是这样子的：

```shell
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := helloworld
LOCAL_SRC_FILES := helloworld.c
include $(BUILD_SHARED_LIBRARY)
```

==说明== 

`LOCAL_PATH := $(call my-dir)`

Android.mk必须以LOCAL_PATH变量开头，用来定位在开发树(development tree)中的源码文件，“my-dir”由编译系统提供，用来返回当前目录（包含Android.mk文件的目录）。

`include $(CLEAR_VARS)`

CLEAR_VARS变量有编译系统提供，它指向一个特殊的GNU makefile，该makefile将清除许多LOCAL_XXX变量（如LOCAL_MODULE,LOCAL_SRC_FILES,LOCAL_STATIC_LIBRARIED等），但LOCAL_PATH除外。这个是有必要的，因为所有的编译控制文件将在单一的GNU编译执行context（所有的变量都是global的）中解析。

`LOCAL_MODULE:=helloworld`

标识描述在Android.mk中的每一个module，改名字必须唯一并且不能有空格

> 编译系统会自动给相应的生成文件添加合适的前缀和后缀，如一个名字为foo的shared library module，将生成‘libfoo.so’。如果名字为libfoo，则编译系统不会额外添加lib前缀。

`LOCAL_SRC_FILES:=helloworld.c`

包含将被编译到module的一系列的C/C++源码文件。

> 默认的c++源文件扩展名为‘.cpp’，可以通过变量LOCAL_DEFAULT_CPP_EXTENSION来指定为不同的扩展名。

`include $(BUILD_SHARED_LIBRARY)`

BUILD_SHARED_LIBRARY是有编译系统提供的变量，指向一个GNU的makefile脚本，负责收集所有最近一次‘include $(CLEAR_VARS)’后定义在LOCAL_XXX中变量，并且决定编译什么和如何精确实现。同样，`BUILD_STATIC_LIBRARY`用来生成static library。

### 自定义变量

NDK编译系统保留以下变量名：

+ 以`LOCAL_`开头
+ 以`PRIVATE` `NDK_` 或 `APP_`开头（内部使用）
+ 小写名字（内部使用，如‘my-dir’）

推荐使用`MY_`前缀来定义Android.mk中自己的变量，如

```shell
MY_SOURCES := foo.c
ifneq ($(MY_CONFIG_BAR),)
   MY_SOURCES += bar.c
endif
LOCAL_SRC_FILES += $(MY_SOURCES)
```



### NDK提供的变量

`CLEAR_VARS`

指向一个编译脚本，该脚本将取消几乎所有列在module描述块（"Module-description" section）下的LOCAL_XXX变量的定义。必须在添加一个新的module之前include该脚本，如

include $(CLEAR_VARS)

`BUILD_SHARED_LIBRARY`

指向一个编译脚本，该脚本将收集所有使用LOCAL_XXX提供的关于指定module的信息，并决定如何从列处的源码中编译目标共享库，在include该文件之前，必须先至少定义LOCAL_MODULE和LOCAL_SRC_FILES，用法如：

include $(BUILD_SHARED_LIBRARY)

`BUILD_STATIC_LIBRARY`

编译目标静态库。静态库不会复制进工程/包中，但可以用来编译共享库。用法如：

include $(BUILD_STATIC_LIBRARY)

> 将生成名字为libs$(LOCAL_MODULE).a的文件

`TARGET_ARCH`

由完整Android源码编译指定的目标CPU架构的名字。'arm'表示所有ARM兼容的编译。

`TARGET_PLATFORM`

Android.mk解析时目标Android平台的名称，如'android-1.5'

`TARGET_ARCH_ABI`

Android.mk解析时目标CPU+ABI的名称，如'arm'

`TARGET_ABI`

目标平台和abi的级联（concatenation），默认为'android-1.5-arm'



### NDK提供的方法宏

以下为GNU编译的方法宏，必须使用"$(call \<function\>)"来引用，它们返回的是文本信息

`my-dir`

返回当前Android.mk的目录，如

LOCAL_PATH := $(call my-dir)

`all-subdir-makefiles`

返回所有位于当前'my-dir'路径子目录下的Android.mk，如下面层级：

sources/foo/Android.mk

sources/foo/lib1/Android.mk

sources/foo/lib2/Android.mk

如果sources/foo/Android.mk包含了行

include $(call all-subdir-makefiles)

将自动include 

sources/foo/lib1/Android.mk和sources/foo/lib2/Android.mk

该方法可以用来向编译系统提供源码目录层级的深度嵌套。

> NDK系统默认只会查找sources/*/Android.mk

`this-makefile`

返回当前makefile的路径

`parent-makefiel`

返回在包含树（inclusion tree）中上一层的makefile，比如包含当前makefile的makefile的路径

`grand-parent-makefile`

猜一猜...(原文译)

### module描述变量

用于向编译系统描述module，需要将一部分定义在'include $(CLEAR_VARS)'和'include \$(BUILD_XXXXX)'之间

`LOCAL_PATH`

当前文件路径，必须定义在Android.mk文件开头，如

LOCAL_PATH := $(call my-dir)

该变量不会被$(CLEAR_VARS)清除

`LOCAL_MODULE`

module的名称，唯一并且无空格，必须定义在任何$(BUILD_XXXX)脚本之前。该名称决定了生成的文件的名称，如lib\<foo>.so

`LOCAL_SRC_FILES`

用来编译module的源文件列表，如

LOCAL_SRC_FILES := foo.c \

​					toto/bar.c

`LOCAL_CPP_EXTENSION`

可选变量，定义c++源文件的扩展名，如

LOCAL_CPP_EXTENSION := .cxx

`LOCAL_CFLAGS`

一套可选的编译器标志，在编译C源文件时使用(不是C++源码)

`LOCAL_CXXFLAGS`

与LOCAL_CFLAGS一样，应用于C++源文件

`LOCAL_CPPFLAGS`

与LOCAL_CFLAGS一样，同时应用于C和C++源文件

`LOCAL_STATIC_LIBRARIES`

罗列出将链接到该module的静态库的modules(使用BUILD_STATIC_LIBRARY编译的module)，仅在共享库module中有意义。

`LOCAL_SHARED_LIBRARIES`

罗列出该module在运行时依赖的共享库的module

> Note that this does not append the listed modules to the build graph,i.e. you should still add them to your application's required modules in your Application.mk

## 将libs目录下的jar添加到Android.mk

1. 在LOCAL_STATIC_JAVA_LIBRARIES处使用标识名(此处不一定是库名称)来定义需要添加的library(多个库之间用'\'来分隔)
2. 执行CLEAR_VARS
3. 使用LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES来定义第一步中添加的库
4. 执行BUILD_MULTI_PREBUILT

一个完整的添加例子

```shell
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_SRC_FILES := $(call all-java-files-under, src)

LOCAL_PACKAGE_NAME := MyProject

LOCAL_STATIC_JAVA_LIBRARIES := libjsch

include $(BUILD_PACKAGE)

include $(CLEAR_VARS)

LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := libjsch:libs/jsch-0.1.49.jar

include $(BUILD_MULTI_PREBUILT)
```



















