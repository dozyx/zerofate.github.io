---
title: GSON - 解析 JSON 的开源库
tags:
  - android
date: 2017-05-16 15:37:22
categories: 笔记
---

[gson github](https://github.com/google/gson)

[Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) （文章内容主要翻译自此系列文章）

GSON 是一个由谷歌开发，用于 JSON 数据和 Java 对象相互转化的序列化/反序列化开源库。 

## 基本使用

### Java - JSON 序列化

有一个Java 类为

```java
public class UserSimple {  
    String name;
    String email;
    int age;
    boolean isDeveloper;
}
```

假如需要将一个 UserSimple 对象用 JSON 表示，如

```json
{
  "name": "Norman",
  "email": "norman@futurestud.io",
  "age": 26,
  "isDeveloper": true
}
```

首先，创建该 Java 对象

```java
UserSimple userObject = new UserSimple(  
    "Norman", 
    "norman@futurestud.io", 
    26, 
    true
);
```

然后，实现序列化

```java
Gson gson = new Gson(); 
String userJson = gson.toJson(userObject); 
```

userJson 的值为

```
{
    "age": 26,
    "email": "norman@futurestud.io",
    "isDeveloper": true,
    "name": "Norman",
}
```

可以看到，Gson 根据字母顺序对字段进行了重排序。

### JSON - Java 反序列化

JSON 字符串（为了减少`\"`的使用，将`"`改成了`'`）

```java
String userJson = "{'age':26,'email':'norman@futurestud.io','isDeveloper':true,'name':'Norman'}";  
```

然后转化

```java
Gson gson = new Gson();
UserSimple userObject = gson.fromJson(userJson, UserSimple.class);  
```



## 内嵌对象序列化

UserNested 类

```java
public class UserNested {  
    String name;
    String email;
    boolean isDeveloper;
    int age;

    UserAddress userAddress;
}

public class UserAddress {  
    String street;
    String houseNumber;
    String city;
    String country;
}
```

将一个 UserNested 对象转为 JSON ，其中，userAddress 是一个内嵌的对象，如

```json
{
    "age": 26,
    "email": "norman@futurestud.io",
    "isDeveloper": true,
    "name": "Norman",

    "userAddress": {
        "city": "Magdeburg",
        "country": "Germany",
        "houseNumber": "42A",
        "street": "Main Street"
    }
}
```

### 内嵌对象序列化

```java
UserAddress userAddress = new UserAddress(  
    "Main Street", 
    "42A", 
    "Magdeburg", 
    "Germany"
);

UserNested userObject = new UserNested(  
    "Norman", 
    "norman@futurestud.io", 
    26, 
    true, 
    userAddress
);

Gson gson = new Gson();  
String userWithAddressJson = gson.toJson(userObject);  
```



### 内嵌对象反序列化

JSON 数据

```json
{
  "name": "Future Studio Steak House",
  "owner": {
    "name": "Christian",
    "address": {
      "city": "Magdeburg",
      "country": "Germany",
      "houseNumber": "42A",
      "street": "Main Street"
    }
  },
  "cook": {
    "age": 18,
    "name": "Marcus",
    "salary": 1500
  },
  "waiter": {
    "age": 18,
    "name": "Norman",
    "salary": 1000
  }
}
```

在转换为 Java 对象之前，我们需要根据 JSON 数据定义 model 类，其中 UserAddress 是复用的前面定义的类

```java
public class Restaurant {//model 的基类
    String name;

    Owner owner;
    Cook cook;
    Waiter waiter;

    public class Owner {
        String name;
        UserAddress address;
    }

    public class Cook {
        String name;
        int age;
        int salary;
    }

    public class Waiter {
        String name;
        int age;
        int salary;
    }
}
```

最后，进行 JSON 转化

```java
String restaurantJson = "{ 'name':'Future Studio Steak House', 'owner':{ 'name':'Christian', 'address':{ 'city':'Magdeburg', 'country':'Germany', 'houseNumber':'42', 'street':'Main Street'}},'cook':{ 'age':18, 'name': 'Marcus', 'salary': 1500 }, 'waiter':{ 'age':18, 'name': 'Norman', 'salary': 1000}}";

Gson gson = new Gson();

Restaurant restaurantObject = gson.fromJson(restaurantJson, Restaurant.class);  
```



## 映射数组和对象列表

​	在 JSON 数据形式中，并没有数据和 List之分，因此，以下内容将它们均视为对象列表。

### Arrays/Lists 的数据序列化

RestaurantWithMenu类

```java
public class RestaurantWithMenu {  
    String name;

    List<RestaurantMenuItem> menu;
    //RestaurantMenuItem[] menu; // alternative, either one is fine
}

public class RestaurantMenuItem {  
    String description;
    float price;
}
```

 我们希望转化后的 JSON 形式如下

```json
{
  "name": "Future Studio Steak House",
  "menu": [
    ...
  ]
}
```

#### 示例1

使用 GSON 将 Java 对象转为 JSON

```java
List<RestaurantMenuItem> menu = new ArrayList<>();  
menu.add(new RestaurantMenuItem("Spaghetti", 7.99f));  
menu.add(new RestaurantMenuItem("Steak", 12.99f));  
menu.add(new RestaurantMenuItem("Salad", 5.99f));

RestaurantWithMenu restaurant =  
        new RestaurantWithMenu("Future Studio Steak House", menu);

Gson gson = new Gson();  
String restaurantJson = gson.toJson(restaurant);  
```

最后的 restaurantJson 内容如下

```json
{
  "menu": [
    {
      "description": "Spaghetti",
      "price": 7.99
    },
    {
      "description": "Steak",
      "price": 12.99
    },
    {
      "description": "Salad",
      "price": 5.99
    }
  ],
  "name": "Future Studio Steak House"
}
```

#### 示例2

假如我们只是对列表进行 JSON 序列化

```java
List<RestaurantMenuItem> menu = new ArrayList<>();  
menu.add(new RestaurantMenuItem("Spaghetti", 7.99f));  
menu.add(new RestaurantMenuItem("Steak", 12.99f));  
menu.add(new RestaurantMenuItem("Salad", 5.99f));

Gson gson = new Gson();  
String menuJson = gson.toJson(menu); 
```

得到的内容将如下

```json
[
  {
    "description": "Spaghetti",
    "price": 7.99
  },
  {
    "description": "Steak",
    "price": 12.99
  },
  {
    "description": "Salad",
    "price": 5.99
  }
]
```

从中可以发现，`[`表示的是对象列表，而`{`表示的是对象。



### Arrays/Lists 的数据反序列化

#### Lists 作为根对象

```json
[
    {
      "name": "Christian",
      "flowerCount": 1
    },
    {
      "name": "Marcus",
      "flowerCount": 3
    },
    {
      "name": "Norman",
      "flowerCount": 2
    }
]
```

创建 model

```java
public class Founder {  
    String name;
    int flowerCount;
}
```

##### 转为数组

```java
String founderJson = "[{'name': 'Christian','flowerCount': 1}, {'name': 'Marcus', 'flowerCount': 3}, {'name': 'Norman', 'flowerCount': 2}]";

Gson gson = new Gson();  
Founder[] founderArray = gson.fromJson(founderJson, Founder[].class);  
```

##### 转为 List

不能直接将 List 对象传给 GSON，需要先找到它的 Type……..不懂...........

```java
String founderJson = "[{'name': 'Christian','flowerCount': 1}, {'name': 'Marcus', 'flowerCount': 3}, {'name': 'Norman', 'flowerCount': 2}]";

Gson gson = new Gson();

Type founderListType = new TypeToken<ArrayList<Founder>>(){}.getType();

List<Founder> founderList = gson.fromJson(founderJson, founderListType);  
```

#### List 作为对象的一部分

```json
{
  "name": "Future Studio Dev Team",
  "website": "https://futurestud.io",
  "founders": [
    {
      "name": "Christian",
      "flowerCount": 1
    },
    {
      "name": "Marcus",
      "flowerCount": 3
    },
    {
      "name": "Norman",
      "flowerCount": 2
    }
  ]
}
```

创建 model

```java
public class GeneralInfo {  
    String name;
    String website;
    List<Founder> founders;
}
```

转化

```java
String generalInfoJson = "{'name': 'Future Studio Dev Team', 'website': 'https://futurestud.io', 'founders': [{'name': 'Christian', 'flowerCount': 1 }, {'name': 'Marcus','flowerCount': 3 }, {'name': 'Norman','flowerCount': 2 }]}";

Gson gson = new Gson();

GeneralInfo generalInfoObject = gson.fromJson(generalInfoJson, GeneralInfo.class);
```



## @SerializedName注解

通过@SerializedName注解可以修改 Java 对象映射到 JSON 的名称。

```json
public class UserSimple {  
    @SerializedName("fullName")
    String name;
    String email;
    boolean isDeveloper;
    int age;
}
```

还可以给@SerializedName 设置多个名称

```java
public class UserSimpleSerializedName {  
    @SerializedName(value = "fullName", alternate = "username")
    private String name;

    private String email;
    private boolean isDeveloper;
    private int age;
}   
```

如果GSON 通过该 model 创建 JSON，则仍会使用 value，但反过来时，两个值都可以被识别。



## 后记

​	在[Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) 系列文章中还介绍了使用 GSON 进行Map 与 JSON 转化、Set 与 JSON转化、null 值的处理，以及其他的一些高级用法，在此文章中就不再进行说明，等到实际使用到再进一步说明。（偷懒一下吧）

​	**在 Android Studio 中，可以使用插件 GsonFormat 来快速生成对象 model。**





