---
title: 设计模式 - 迭代器
tags:
  - 设计模式
date: 2017-07-28 15:37:22
categories: 笔记
---

[design-pattern-java](https://gof.quanke.name/)

## JDK 中的 Iteratable 和 Iterator

​	Iteratable 是一个接口类，实现该接口的对象可用于 "for-each loop)"语句。该接口的 Iterator() 方法返回一个 Iterator 对象。

```java
public interface Iterable<T> {
    Iterator<T> iterator();
  	...
}
```

> 在 java8 中，Iterable 接口中添加了两个 default 方法 forEach 和 spilterator，对于这两个方法的用法还没有进行了解。
>
> 注：default 关键字也是从 java8 中进行引入的，用于扩展接口添加新的方法，实际上就是一个默认实现，这就像是 c++中的虚函数和纯虚函数之分。

​	Iterator 迭代器同样也是一个 interface，用于集合。

```java
public interface Iterator<E> {
    /**
     * 是否还有更多的元素，即 next() 方法是否会返回一个元素而不是抛出异常
     */
    boolean hasNext();

    /**
     * 如果没有更多的素数则抛出 NoSuchElementException
     */
    E next();

    /**
     * 从底层集合中移除该迭代器上一个返回的元素
     * 每一次 next() 方法的调用只能调用一次该方法(拗口。。。)
     * 在迭代过程中，如果底层集合被非 remove() 的其他任意方式修改，将导致该迭代器行为不明
     * 如果迭代器不支持该方法则抛出 UnsupportedOperationException;如果 next() 还没有被
     * 调用或者自上次调用 next() 后已经调用过 remove()，则抛出 IllegalStateException
     */
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
  	...
}

```

> Java8 增加了一个 default 的 forEachRemaining(…) 方法。



## 迭代器模式

​	迭代器模式提供一种方法**顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示**，其别名为游标（Cursor）。该模式的关键思想是将**对列表的访问和遍历从列表对象中分离并放入一个迭代器对象中**。迭代器类定义了一个访问该列表元素的接口，迭代器对象负责跟踪当前的元素，即，它知道哪些元素已经遍历过了。

​	由于迭代器需要持有对具体聚合对象的引用，所以，为了能够让迭代器可以访问到聚合对象中的数据，可以将迭代器类设计为聚合类的内部类，如 JDK 中的 AbstractList 类。

​	个人理解：首先，需要建立一种模式的观念——迭代器模式并不是一种具体的实现，而是一种思想，通过迭代器模式来实现对聚合类的遍历，而又不需要暴露聚合类的实现；抽象迭代器接口（或抽象类）定义一套遍历的方法，聚合类提供创建迭代器对象的方法（通常是工厂方法），即具体聚合类既负责储存数据，也需要实现获取迭代器对象的方法。

​	