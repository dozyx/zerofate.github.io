---
title: ListView 高亮某一项
tags:
  - android
date: 2017-01-23 15:37:22
categories: 笔记
---

### 利用单选实现

listview设置为单选，并通过setItemChecked设置高亮

listview.setChoiceMode(ListView.CHOICE_MODE_SINGLE);

listview.setItemChecked(0, true);

childView需要设置背景drawable，drawable中需要有item为state_activited



#### 从 Android Settings 源码追踪高亮实现

Settings 在自定义的 style 中重新设置了 Preference 的layout，该布局的background属性为

`android:background="?android:attr/activatedBackgroundIndicator"`

activatedBackgroundIndicator属性默认引用的是activated_background.xml的drawable，在该drawable中根据state_activated状态选择drawable

```xml
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_activated="true" android:drawable="@android:drawable/list_selector_background_selected" />
    <item android:drawable="@color/transparent" />
</selector>

```



### 关于 ListView 的 android:listSelector 属性

​	在一开始实现高亮需求，以为可以 android:listSelector 属性来达到目的，然后各种调整 state ，出现的却是各种奇怪的现象：如 setSelection 没变化（我以为会有变化），selected 状态的背景在长按时才生效。这些现象对于当时的我来说的确有点费解，在隔了半年后，重新思考了这个属性，并在源码上对其进行一下解释。由于没怎么见到过这个属性的使用场景加上自己目前水平所限，所以可能有些东西也没未必正确，在这里只是作为自己一些思考的记录。

#### 源码分析

android:listSelector 属性属于 AbsListView，也可以通过 setSeletor 方法动态设置，实际上，在解析 xml 中的这个属性后，最后也是通过 setSelector 方法来使用。

```java
	/**
     * Set a Drawable that should be used to highlight the currently selected item.
     *
     * @param resID A Drawable resource to use as the selection highlight.
     *
     * @attr ref android.R.styleable#AbsListView_listSelector
     */
    public void setSelector(@DrawableRes int resID) {
        setSelector(getContext().getDrawable(resID));
    }

    public void setSelector(Drawable sel) {
        if (mSelector != null) {
            mSelector.setCallback(null);
            unscheduleDrawable(mSelector);
        }
        mSelector = sel;
        Rect padding = new Rect();
        sel.getPadding(padding);
        mSelectionLeftPadding = padding.left;
        mSelectionTopPadding = padding.top;
        mSelectionRightPadding = padding.right;
        mSelectionBottomPadding = padding.bottom;
        sel.setCallback(this);
        updateSelectorState();
    }
```

​	从文档说明上可以知道，selector 正是用来高亮 selected 项的。但为什么无法真正实现高亮的需求呢？实际上，根本原因在于对 selected 状态的理解—— selected 状态在 touch mode 模式（只要触摸了屏幕，手机就会一直处于该模式，如果想要对这个模式有更好的了解，可以参考[这篇文章](https://android-developers.googleblog.com/2008/12/touch-mode.html)）是不存在的。那么，难道 setSelection(…) 方法没有设置 selected 状态？看下 setSelection 方法的源码

```java
	//ListView.java
	/**
     * Sets the currently selected item. If in touch mode, the item will not be selected
     * but it will still be positioned appropriately. If the specified selection position
     * is less than 0, then the item at position 0 will be selected.
     *
     * @param position Index (starting at 0) of the data item to be selected.
     */
    @Override
    public void setSelection(int position) {
        setSelectionFromTop(position, 0);
    }
```

​	文档注释就已经说明，touch mode 时，item 不会被 selected，但会被合适的放置，所以这个方法更好的理解应该是设置 position 的位置，而不是设置状态。

​	继续看 updateSelectorState() 方法的实现

```java
    void updateSelectorState() {
        final Drawable selector = mSelector;
        if (selector != null && selector.isStateful()) {
            if (shouldShowSelector()) {
                if (selector.setState(getDrawableStateForSelector())) {
                    invalidateDrawable(selector);
                }
            } else {
                selector.setState(StateSet.NOTHING);
            }
        }
    }
	 /**
     * Indicates whether this view is in a state where the selector should be drawn. 
     * This will happen if we have focus but are not in touch mode, or we are in the 	   
     * middle of displaying the pressed state for an item.
     *
     * @return True if the selector should be shown
     */
    boolean shouldShowSelector() {
        return (isFocused() && !isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
    }
```

​	从 shouldShowSelector 可以看到，除非 selector 的条件有两个：

1. AbsListView 处于 focused 状态且不处于 touch mode
2. 处于 pressed 状态，touchModeDrawsInPressedState()为 true 也有两种情况，一种是用户按下后等待判断是否为一个 longpress，另一种是已经等待了所有可能情况后仍处于按下状态（就是用户一直没松开）



​	上面的两个条件就是真正触发 selector 生效的条件了，如果不满足，就根本什么都不会发生。getDrawableStateForSelector() 用来得到 selector对应的 state，在 childView 为 enabled 时，会根据 childView 的状态进行选择，否则，会根据 absListView 除 enabled 外的其他状态进行选择。



