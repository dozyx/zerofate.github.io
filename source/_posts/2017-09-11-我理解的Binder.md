---
title: 我所理解的Binder
tags:
  - android
date: 2017-09-11 00:53:03
categories: 编程
---

> 感觉面试又挂了，一次很纯粹的技术面，问的都是其实都比较基本，但很多感觉会用的东西，却又说不清楚，还是说其实我就是不会。比如被问到 Binder 机制，明明都看过书和视频，当时都感觉大概理解了，结果被问到却啥也说不清楚，奇怪得连个思路都没有，有种“ Binder是什么 == 我是谁”的感觉，大概我的大概就是不会吧。那么，Binder 究竟是什么呢？

> 写完这篇文章后，感觉有些东西还是没能完全串联起来，估计如果要完全理解还是需要理解底层才能明白，暂时先凑合吧。
>

## AIDL

AIDL 是 Binder 的一个实际应用，先来回顾一下 AIDL 的常用用法：

+ 创建 IRemoteService.aidl 文件：与普通 interface 类似，我们需要在 aidl 文件中声明用于 IPC 的方法，接着 SDK 将为我们自动生成一个 IRemoteService.java 文件，这样我们就得到了一个完整的 IRemoteService 接口，这个接口实际上也可以不通过 aidl 文件而是由我们根据 Binder 机制自己编写。
+ 服务端
  + 继承 IRemoteService.Stub 类并实现 aidl 中的方法：Stub 类是一个继承 Binder 的内部抽象类。
  + 在 onBind() 中返回 IRemoteService.Stub 实现
+ 客户端
  + bindService
  + 在 onServiceConnected 回调中通过 IRemoteService.Stub 的 asInterface() 方法得到 IRemoteService 对象



### 数据类型

AIDL 在定义时支持以下数据类型：

+ 基本类型
+ String、CharSequenue
+ List：只支持 ArrayList。注意，如果我们在服务端实现时使用的是 CopyOnWriteArrayList（不是继承自 ArrayList）或 ConcurrentHashMap 也是可以的，因为我们在 AIDL 方法中返回的是 List 接口，而 Binder 将会按照 List 规范去访问数据并最终形成一个新的 ArrayList 传递给客户端。
+ Map：只支持 HashMap
+ Parcelable
+ AIDL

> 自定义的 Parcelable 和 AIDL 必须显式 import，另一个需要注意的是，如果 AIDL 文件中使用了自定义的 Parcelable 对象，那么必须新建一个和它同名的 AIDL 文件并声明它为 parcelable。如一个实现了 Parcelable 的 Book 类，如果需要在 AIDL 中使用，那么必须创建一个 Book.aidl，然后添加如下内容：
>
> *package ...*
>
> *parcelable Book;*



### 数据走向

AIDL 除了基本类型外，其他类型参数必须添加指示数据走向的方向标记（AIDL 是有服务端提供了，所以表示的是相对于服务端的走向），AIDL 提供了三种走向，默认为 in：

+ in：输入型参数
+ out：输出型参数
+ inout：输入输出型参数

> 我们需要谨慎选择自己需要的走向，因为不同走向的开销存在差异



### 权限验证

在 AIDL 中使用权限验证功能有两种常用方法：

+ 在 onBind 中验证
  + 使用 permission 验证：在 AndroidManifest 中声明权限，onBind 中使用 checkCallingOrSelfPermission 方法检测权限，如果没有该权限则返回 null
+ 在服务端的 onTransact 方法中进行权限验证，如果验证失败则直接返回 false，具体的验证方式有多种：
  + permission 验证
  + 使用 Uid 和 Pid 来验证：通过 getCallingUid 和 getCallingPid 可以获得客户端所属得的 Uid 和 Pid，我们可以利用这两个参数来验证包名。



## Binder

对于 Binder 框架的概述，觉得张鸿洋的 《Android aidl Binder 框架浅析》总结得挺好的，这里引用下

> Android Binder框架分为服务器接口、Binder驱动、以及客户端接口；简单想一下，需要提供一个全局服务，那么全局服务那端即是服务器接口，任何程序即客户端接口，它们之间通过一个Binder驱动访问。
>
> 服务器端接口：实际上是Binder类的对象，该对象一旦创建，内部则会启动一个隐藏线程，会接收Binder驱动发送的消息，收到消息后，会执行Binder对象中的onTransact()函数，并按照该函数的参数执行不同的服务器端代码。
>
> Binder驱动：该对象也为Binder类的实例，客户端通过该对象访问远程服务。
>
> 客户端接口：获得Binder驱动，调用其transact()发送消息至服务器



### 通讯

Binder 类是 Binder 机制的核心，它实现了 IBinder 接口，IBinder 的核心 API 是 transact()，在进行客户端与服务端的通讯时，就是通过该方法进行方法调用、参数传入、结果回传。首先看下该方法的声明：

```java
public boolean transact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException;
```

code：标识执行的方法。每一个方法都对应 FIRST_CALL_TRANSACTION 和 LAST_CALL_TRANSACTION 间的一个数字。

data：客户端传入的参数，如果没有参数，仍需提供一个空的 Parcel。

reply：服务端返回的数据。

flags：额外操作的标记，0 普通 RPC 或者 FLAG_ONEWAY 单向 RPC（调用者将立即返回而不需要等待被调用者的结果）



### 从 AIDL 实例代码分析

+ 首先编写一个 IHello.aidl 文件：

```java
// IHello.aidl
package com.zerofate.android.zerotemplate.aidl;

// Declare any non-default types here with import statements

interface IHello {
    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);

    void hello(String msg);
    String getReply();
}
```

basicTypes 为自动生成方法，我们在 IHello 中声明了两个接口方法 hello() 和 getReply()。

+ SDK 生成的 IHello.java 如下

```java
/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: /Users/zero/Desktop/GitRepo/ZeroTemplate/app/src/main/aidl/com/zerofate/android
 * /zerotemplate/aidl/IHello.aidl
 */
package com.zerofate.android.zerotemplate.aidl;
// Declare any non-default types here with import statements

public interface IHello extends android.os.IInterface {
    /** Local-side IPC implementation stub class. */
    public static abstract class Stub extends android.os.Binder implements
            com.zerofate.android.zerotemplate.aidl.IHello {
        private static final java.lang.String DESCRIPTOR =
                "com.zerofate.android.zerotemplate.aidl.IHello";

        /** Construct the stub at attach it to the interface. */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.zerofate.android.zerotemplate.aidl.IHello interface,
         * generating a proxy if needed.
         */
        public static com.zerofate.android.zerotemplate.aidl.IHello asInterface(
                android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) && (iin instanceof com.zerofate.android.zerotemplate.aidl.IHello))) {
                return ((com.zerofate.android.zerotemplate.aidl.IHello) iin);
            }
            return new com.zerofate.android.zerotemplate.aidl.IHello.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,
                int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_basicTypes: {
                    data.enforceInterface(DESCRIPTOR);
                    int _arg0;
                    _arg0 = data.readInt();
                    long _arg1;
                    _arg1 = data.readLong();
                    boolean _arg2;
                    _arg2 = (0 != data.readInt());
                    float _arg3;
                    _arg3 = data.readFloat();
                    double _arg4;
                    _arg4 = data.readDouble();
                    java.lang.String _arg5;
                    _arg5 = data.readString();
                    this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);
                    reply.writeNoException();
                    return true;
                }
                case TRANSACTION_hello: {
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _arg0;
                    _arg0 = data.readString();
                    this.hello(_arg0);
                    reply.writeNoException();
                    return true;
                }
                case TRANSACTION_getReply: {
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _result = this.getReply();
                    reply.writeNoException();
                    reply.writeString(_result);
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.zerofate.android.zerotemplate.aidl.IHello {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            /**
             * Demonstrates some basic types that you can use as parameters
             * and return values in AIDL.
             */
            @Override
            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
                    double aDouble, java.lang.String aString) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeInt(anInt);
                    _data.writeLong(aLong);
                    _data.writeInt(((aBoolean) ? (1) : (0)));
                    _data.writeFloat(aFloat);
                    _data.writeDouble(aDouble);
                    _data.writeString(aString);
                    mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }

            @Override
            public void hello(java.lang.String msg) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeString(msg);
                    mRemote.transact(Stub.TRANSACTION_hello, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }

            @Override
            public java.lang.String getReply() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                java.lang.String _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    mRemote.transact(Stub.TRANSACTION_getReply, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.readString();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
        }

        static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_hello = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_getReply = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
    }

    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble,
            java.lang.String aString) throws android.os.RemoteException;

    public void hello(java.lang.String msg) throws android.os.RemoteException;

    public java.lang.String getReply() throws android.os.RemoteException;
}

```

自动生成的代码由于没有经过格式化，所以乍看起来很乱，不过实际如果按照层次分析理解后会发现并没有多少东西，整个代码也不过一百多行。

+ 整体结构：

  + IHello 是一个 interface，它继承了 IInterface 接口，IInterface 中声明了唯一一个方法 asBinder()，通过自动生成的 IHello 还重新对我们在 aidl 文件中声明的文件进行了声明
  + 但是，我们实际使用中，并不需要实现 IHello 接口，在服务端中实现的是 IHello.Stub 类，Stub （根）类继承了 Binder 并且实现了 IHello 接口。Stub 是一个抽象类，我们在使用时主要需要实现的正是我们在 aidl 中实现的类，aidl 为我们自动生成的是模板代码。

+ 常量：我们需要为每一个方法定义一个常量，transact() 中将利用这个常量来判断执行的方法；Stub 类中有一个 DESCRIPTOR常量，它是 Binder 的唯一标识，一般用当前 Binder 的类名表示。

+ 一个方法的完整调用：

  + 客户端如果需要调用服务端的方法，那么它首先需要得到一个 IHello 对象，通常是在 onServiceConnected() 中利用 IHello.Stub.asInterface(service) 获得，其中 service 是一个 IBinder 对象。asInterface() 方法最后返回的是：

    ```java
    return new com.zerofate.android.zerotemplate.aidl.IHello.Stub.Proxy(obj);
    ```

    > 如果客户端与服务端在同一个进程中，那么 asInterface 返回的不是 Proxy，而是 onBind() 返回的Binder。

    Proxy 代理类同样实现了 IHello 接口，但它的实现是对方法数据的一个处理，最后实际调用的实际还是 传入的 IBinder 对象的方法。比如 getReply() 在 Proxy 中的实现：

    ```java
                @Override
                public java.lang.String getReply() throws android.os.RemoteException {
                    android.os.Parcel _data = android.os.Parcel.obtain();
                    android.os.Parcel _reply = android.os.Parcel.obtain();
                    java.lang.String _result;
                    try {
                        _data.writeInterfaceToken(DESCRIPTOR);
                        mRemote.transact(Stub.TRANSACTION_getReply, _data, _reply, 0);
                        _reply.readException();
                        _result = _reply.readString();
                    } finally {
                        _reply.recycle();
                        _data.recycle();
                    }
                    return _result;
                }
    ```

    它将数据封装为 Parcel 对象，然后实际是调用 transact() 来执行方法。

  + 从上面可以看到客户端在调用 aidl 方法时，实际上利用了 onServiceConnected 回调中获得的 IBinder 对象并执行 transact()，然后将调用 Binder 的 onTransact() 方法：

    ```java
            @Override
            public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,
                    int flags) throws android.os.RemoteException {
                switch (code) {
                    case INTERFACE_TRANSACTION: {
                        ...
                    }
                    case TRANSACTION_basicTypes: {
                        ...
                    }
                    case TRANSACTION_hello: {
                        ...
                    }
                    case TRANSACTION_getReply: {
                        data.enforceInterface(DESCRIPTOR);
                        java.lang.String _result = this.getReply();
                        reply.writeNoException();
                        reply.writeString(_result);
                        return true;
                    }
                }
                return super.onTransact(code, data, reply, flags);
            }
    ```

    在 onTransact() 方法中将调用我们服务端实现的 Stub 里的方法，并将返回值写入 reply 中。

+ 通过分析，其实可以发现，aidl 只是 SDK 提供的一个使用 Binder 的工具，我们也可以在不编写 aidl 的情况下利用 Binder 实现进程间通讯，我们需要做的是在客户端提供 transact() 方法需要的参数，然后在服务端的 onTransact() 中判断执行的方法，解析数据、进行计算，然后将返回值写入 reply 中（如果有）。









> 草稿：
>
> + IBinder 接口
>   + Binder 类是 IBinder 接口的实现
>   + IBinder 接口描述了与远程对象通讯的抽象协议。
>   + 不要直接实现此接口，而是继承 Binder
>   + IBinder 的核心 API 是 transact() 方法，它对应于 Binder.onTransact() 方法，该 事务 API 是同步的。通过 transact() 发送的数据是一个 Parcel，该 Parcel 是一个通用的数据缓存区，同时还会保留其相关内容的一些元数据，这些元数据用于管理缓存区中的 IBinder 对象的引用，这样当缓存区在进程间移动时，这些引用仍能被保留下来。
>   + 系统会在运行的每个进程中维护一个事务（transaction）线程池，这些线程将分发给所以其他进程发起的 IPC。比如，一个从进程 A 到进程 B 的 IPC，当 A 发送事务给进程 B 时，A 中的调用线程将阻塞在 transact() 中。而 B 的下一个可用池线程将接收传入的事务，并对目标对象（**？**）调用 Binder.onTransact() ，然后使用结果 Parcel 进行回复。一旦收到结果，进程 A 中的线程将返回并继续执行。实际上，就像其它进程使用了你没有在自己进程中创建的额外线程。
>   + Binder 系统还支持跨进程的递归。
>   + 在使用远程对象时，有三种方式可以判断对象是否还有效
>     + 如果对一个进程已不存在的 IBinder 对象进行调用，transact() 方法将抛出 RemoteException
>     + 可以调用 pingBinder() 方法，如果远程进程不存在，那么它将返回false。（**Binder 类的默认 pingBinder() 实现返回的是true，需要继承 Binder 重写？**）
>     + 使用 linkToDeath() 方法注册一个可以在进程消失时被调用的 IBinder.DeathRecipient 对象
> + Binder 类
>   + 用于远程对象的基类，由 IBinder 所定义的轻量级远程调用机制的核心部分。
>   + 该类是 IBinder 的一个实现，它提供了这种对象的标准本地实现。
>   + 大部分开发者不需要直接实现该类，而是使用 aidl 工具来描述所需的接口，使其生成适当的 Binder 子类。但是，你也可以继承 Binder 来实现自定义的 RPC 协议或者直接实例化一个原始的 Binder 对象作为跨进程共享的令牌。
>   + 必须谨记各种进程消失的情形，需要在适当时候重建一个新的 Binder 并在进程再次启动时重新依附。
> + Parcel 类
>   + **Parcel（包）是一个可用于 IBinder 传送的消息（数据和对象引用）容器**。Parcel 可以包含 flattened （扁平化）数据（将在 IPC 的另一端 unflattened，这个过程可以使用各种特定类型的写方法或者 Parcelable 接口来实现，个人理解是在写入的数据为 flattened，而读取出来时为 unflattened）以及对存活的 IBinder 对象的引用（使接收代理 IBinder 的另一侧连接到 Parcel 中的原始 IBinder）。
>   + Parcel 的大量 API 都围绕着各种类型数据的读取和写入，主要可以分为六型：
>     + **基本类型**：如 writeByte(byte)、readByte() 等
>     + **基本类型数组**：在写入时，会先写入一个 4 字节的数组长度，再写入数组中每个数据；我们可以将数据读取到一个已存在的数据，也可以返回一个新创建的数组。如 writeBooleanArray(boolean[]), readBooleanArray(boolean[]), createBooleanArray()。
>     + **Parcelables**：Parcelable 提供了一种从 Parcel 中高效写入和读取的协议。
>       + 我们可以使用 writeParcelable(Parcelable, int)、 readParcelable(ClassLoader)、 writeParcelableArray(T[], int) 、 readParcelableArray(ClassLoader) 来进行读写，这些方法会将类的类型和它的数据同时写入，并允许后续读取时从适当的类加载器中进行重建。
>       + 除此之外，还提供了一些更高效的用于 Parcelable 的方法： writeTypedObject(T, int)、 writeTypedArray(T[], int)、writeTypedList(List)、readTypedObject(Parcelable.Creator)、createTypedArray(Parcelable.Creator)、 createTypedArrayList(Parcelable.Creator)，这些方法不会写入原始对象的类信息，所以 read 方法的调用者必须知道清楚所需的类型并传入对应的 Parcelable.Creator 。（为了更高效地写入和读取一个单独的非空Parceable 对象，可以直接调用 Parcelable.writeToParcel 和 Parcelable.Creator.createFromParcel）。
>     + Bundles：特殊的类型安全容器，它对数据读写性能进行了优化，对应方法有  writeBundle(Bundle)、readBundle()、readBundle(ClassLoader)。
>     + Active Objects：
>     + Untyped Containers：
> + 注意点
>   + 在 AIDL 中，服务的 onBind() 方法返回的 IBinder 对象与客户端的 onServiceConnected() 中使用的 IBinder 对象不是同一个，客户端获得的实际上是服务端 Binder 的一个代理，其实想想也知道两个进程之间肯定不是同一个。（注意：如果客户端和服务端在同一进程中，那么返回的都是同一个 Binder）
>   + 客户端调用 IPC 方法时将导致线程阻塞，知道 transact() 方法返回
>   + 服务端实现的 IPC 方法被调用时是无法确保该方法所调用的线程的，所以需要考虑方法的多线程处理
>   + 客户端还必须具有对 interface 类的访问权限，因此如果客户端和服务在不同的应用内，则客户端的应用 src/ 目录内必须包含 .aidl 文件（它生成 android.os.Binder 接口 — 为客户端提供对 AIDL 方法的访问权限）的副本。
>   + 服务端应该使用 RemoteCallbackList 来保存客户端传进来的 listener，因为经过 Binder 传输后的 listener 与传入的不是同一个对象
>   + 当服务端调用客户端的 listener 中的方法时，被调用方法运行在客户端的 Binder 线程池
>   + 客户端调用 unbindService() 后，与 Binder 的连接并不会断开
>
>
> 
>






参考资料：

[IBinder Javadoc](https://developer.android.com/reference/android/os/IBinder.html)

[Binder Javadoc](https://developer.android.com/reference/android/os/Binder.html)

[Parcel Javadoc](https://developer.android.com/reference/android/os/Parcel.html)

[AIDL guide](https://developer.android.com/guide/components/aidl.html?hl=zh-cn)

 [Android aidl Binder框架浅析](http://blog.csdn.net/lmj623565791/article/details/38461079)

《Android 开发艺术探索》AIDL、Binder