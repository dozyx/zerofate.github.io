---
title: Training - 管理网络使用情况
tags:
  - android
  - 网络
date: 2017-08-02 15:37:22
categories: 笔记
---

​	[Managing Network Usage](https://developer.android.com/training/basics/network-ops/managing.html#prefs)

​	 [networkusage sample](https://android.googlesource.com/platform/frameworks/base/+/master/samples/training/network-usage/src/com/example/android/networkusage) 

​	如果 app 需要执行大量的网络操作，则应当提供用户设置以控制 app 的数据习惯，如同步数据间隔、是否只在 Wi-Fi 下上传/下载、是否在漫游时使用数据等等。



## 检查设备的网络连接

​	一个设备可以有不同的网络连接，本节只关注 Wi-Fi 或移动网络连接。在检查网络连接时，通常会使用以下类：

+ ConnectivityManager：回应对网络连接状态的查询，当网络连接改变时，也会通知应用
+ NetworkInfo：描述给定类型（目前为 Mobile 或 Wi-Fi）的网络接口的状态



下面的代码片段测试了 Wi-Fi 和 mobile的网络连接

```java
private static final String DEBUG_TAG = "NetworkStatusExample";
...
ConnectivityManager connMgr = (ConnectivityManager)
        getSystemService(Context.CONNECTIVITY_SERVICE);
NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
boolean isWifiConn = networkInfo.isConnected();
networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
boolean isMobileConn = networkInfo.isConnected();
Log.d(DEBUG_TAG, "Wifi connected: " + isWifiConn);
Log.d(DEBUG_TAG, "Mobile connected: " + isMobileConn);
```

​	需要注意的是，不应该基于网络是否“available”来做决定，而是在执行网络操作前检查 isConnected()，因为 isConnected() 处理了如片状移动网络、飞行模式、后台数据限制等多种情况。

​	更简洁的检查方式如下，getActiveNetworkInfo() 返回表示第一连接的网络接口的 NetworkInfo 实例，或者在没有连接网络接口时返回 null。

```java
public boolean isOnline() {
    ConnectivityManager connMgr = (ConnectivityManager)
            getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
    return (networkInfo != null && networkInfo.isConnected());
} 
```



## 管理网络使用情况

​	可以实现一个偏好 Activity 使用户控制 app 对网络资源的使用，如：

+ 仅在设备连接到 Wi-Fi 网络时上传视频
+ 根据特定规则同步（或不同步），如网络可用性、时间间隔等



​	编写一个支持网络访问和网络使用情况管理的 app，需要在 manifest 中添加正确的权限和 intent filter

+ manifest 需要包含以下权限
  + android.permission.INTERNET
  + android.permission.ACCESS_NETWORK_STATE
+ 可以声明一个 action 为 ACTION_MANAGE_NETWORK_USAGE （在 Android 4.0 推出）的 intent filter，它表明了应用定义了一个 activity 来提供控制数据使用的选项。

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.android.networkusage"
    ...>

    <uses-sdk android:minSdkVersion="4"
           android:targetSdkVersion="14" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        ...>
        ...
        <activity android:label="SettingsActivity" android:name=".SettingsActivity">
             <intent-filter>
                <action android:name="android.intent.action.MANAGE_NETWORK_USAGE" />
                <category android:name="android.intent.category.DEFAULT" />
          </intent-filter>
        </activity>
    </application>
</manifest>
```



## 实现一个偏好 Activity

> 暂时没发现响应android.intent.action.MANAGE_NETWORK_USAGE的程序

![network-settings1](https://ws2.sinaimg.cn/large/006tKfTcgy1finv9hhzvaj30640a7aa4.jpg)

​	

![network-settings2](https://ws3.sinaimg.cn/large/006tKfTcgy1finv9h6ln2j30640a73ym.jpg)

​	SettingsActivity 是 PreferenceActivity 的一个子类，并实现了 OnSharedPreferenceChangeListener。

```java
public class SettingsActivity extends PreferenceActivity implements OnSharedPreferenceChangeListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Loads the XML preferences file
        addPreferencesFromResource(R.xml.preferences);
    }

    @Override
    protected void onResume() {
        super.onResume();

        // Registers a listener whenever a key changes
        getPreferenceScreen().getSharedPreferences().registerOnSharedPreferenceChangeListener(this);
    }

    @Override
    protected void onPause() {
        super.onPause();

       // Unregisters the listener set in onResume().
       // It's best practice to unregister listeners when your app isn't using them to cut down on
       // unnecessary system overhead. You do this in onPause().
       getPreferenceScreen().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);
    }

    // When the user changes the preferences selection,
    // onSharedPreferenceChanged() restarts the main activity as a new
    // task. Sets the refreshDisplay flag to "true" to indicate that
    // the main activity should update its display.
    // The main activity queries the PreferenceManager to get the latest settings.

    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
        // Sets refreshDisplay to true so that when the user returns to the main
        // activity, the display refreshes to reflect the new settings.
        NetworkActivity.refreshDisplay = true;
    }
}
```



## 响应偏好更改

​	下面的代码中，将在 onStart() 中检查偏好设置。如果设置与设备网络连接匹配，app 将进行下载并刷新显示

```java
public class NetworkActivity extends Activity {
    public static final String WIFI = "Wi-Fi";
    public static final String ANY = "Any";
    private static final String URL = "http://stackoverflow.com/feeds/tag?tagnames=android&sort=newest";

    // Whether there is a Wi-Fi connection.
    private static boolean wifiConnected = false;
    // Whether there is a mobile connection.
    private static boolean mobileConnected = false;
    // Whether the display should be refreshed.
    public static boolean refreshDisplay = true;

    // The user's current network preference setting.
    public static String sPref = null;

    // The BroadcastReceiver that tracks network connectivity changes.
    private NetworkReceiver receiver = new NetworkReceiver();

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Registers BroadcastReceiver to track network connection changes.
        IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
        receiver = new NetworkReceiver();
        this.registerReceiver(receiver, filter);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // Unregisters BroadcastReceiver when app is destroyed.
        if (receiver != null) {
            this.unregisterReceiver(receiver);
        }
    }
    // Refreshes the display if the network connection and the
    // pref settings allow it.

    @Override
    public void onStart () {
        super.onStart();

        // Gets the user's network preference settings
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);

        // Retrieves a string value for the preferences. The second parameter
        // is the default value to use if a preference value is not found.
        sPref = sharedPrefs.getString("listPref", "Wi-Fi");

        updateConnectedFlags();

        if(refreshDisplay){
            loadPage();
        }
    }

    // Checks the network connection and sets the wifiConnected and mobileConnected
    // variables accordingly.
    public void updateConnectedFlags() {
        ConnectivityManager connMgr = (ConnectivityManager)
                getSystemService(Context.CONNECTIVITY_SERVICE);

        NetworkInfo activeInfo = connMgr.getActiveNetworkInfo();
        if (activeInfo != null && activeInfo.isConnected()) {
            wifiConnected = activeInfo.getType() == ConnectivityManager.TYPE_WIFI;
            mobileConnected = activeInfo.getType() == ConnectivityManager.TYPE_MOBILE;
        } else {
            wifiConnected = false;
            mobileConnected = false;
        }
    }
    
    // Uses AsyncTask subclass to download the XML feed from stackoverflow.com.
    public void loadPage() {
        if (((sPref.equals(ANY)) && (wifiConnected || mobileConnected))
                || ((sPref.equals(WIFI)) && (wifiConnected))) {
            // AsyncTask subclass
            new DownloadXmlTask().execute(URL);
        } else {
            showErrorPage();
        }
    }
...

}
```



## 检测连接更改

​	当设备的网络连接改变时，NetworkReceiver 将监听 CONNECTIVITY_ACTION 来确定网络连接状态。

​	配置一个不必要调用的 BroadcastReceiver 将会消耗系统资源，在 sample 中将使用动态注册，而不是在 manifest 的\<receiver\> 中注册。如果在 \<receiver>中声明并明确知道什么时候需要使用，则可以通过 PackageManager 的 setComponentEnabledSetting() 来启动/关闭。

```java
public class NetworkReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    ConnectivityManager conn =  (ConnectivityManager)
        context.getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = conn.getActiveNetworkInfo();

    // Checks the user prefs and the network connection. Based on the result, decides whether
    // to refresh the display or keep the current display.
    // If the userpref is Wi-Fi only, checks to see if the device has a Wi-Fi connection.
    if (WIFI.equals(sPref) && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI) {
        // If device has its Wi-Fi connection, sets refreshDisplay
        // to true. This causes the display to be refreshed when the user
        // returns to the app.
        refreshDisplay = true;
        Toast.makeText(context, R.string.wifi_connected, Toast.LENGTH_SHORT).show();

    // If the setting is ANY network and there is a network connection
    // (which by process of elimination would be mobile), sets refreshDisplay to true.
    } else if (ANY.equals(sPref) && networkInfo != null) {
        refreshDisplay = true;

    // Otherwise, the app can't download content--either because there is no network
    // connection (mobile or Wi-Fi), or because the pref setting is WIFI, and there
    // is no Wi-Fi connection.
    // Sets refreshDisplay to false.
    } else {
        refreshDisplay = false;
        Toast.makeText(context, R.string.lost_connection, Toast.LENGTH_SHORT).show();
    }
}
```