---
title: 自带 Music 源码学习
tags:
  - android
  - music 
date: 2017-03-07 15:37:22
categories: 笔记
---

​	Music 主界面分为了 4 个 tab：歌手、专辑、歌曲、播放列表(估计是因为 Music 应用开发时没有 Fragment，所以 tab 并不实际存在，每个 tab 都属于一个单独的 Activity，只是 tab 栏位置相同)，相应的 Activity 为ArtistAlbumBrowserActivity、AlbumBrowserActivity、TrackBrowserActivity、PlaylistBrowserActivity。

## 知识点

### Activity 过渡动画

​	在 startActivity() 或 finish() 方法后，调用 overridePendingTransition(int,int) 设置过渡动画，传入的参数为资源 Id。

### 运行时权限判断

​	Music 需要获取读取外部存储权限，checkSelfPermission(String) 和 requestPermissions(String[], int) 均是在 AP23 开始加入的 API。

*MusicBrowserActivity.java*

```java
    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        if (checkSelfPermission(permission.READ_EXTERNAL_STORAGE)
                != PackageManager.PERMISSION_GRANTED) {
            requestPermissions(new String[] {permission.READ_EXTERNAL_STORAGE},
                    MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE);
            return;
        }
        initApp();
    }
```

​	requestPermissions 后，将在 onRequestPermissionsResult(…) 中返回请求结果

```java
    @Override
    public void onRequestPermissionsResult(
            int requestCode, String permissions[], int[] grantResults) {
        switch (requestCode) {
            case MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE: {
                if (grantResults.length == 0
                        || grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    finish();
                    return;
                }
                initApp();
            }
        }
    }
```
### 音乐服务

​	各个组件与音乐服务的通讯是通过 AIDL 方式进行的，在 MusicUtil 类中提供了 bind/unbind 服务的静态方法

```java
public static ServiceToken bindToService(Activity context) {
        return bindToService(context, null);
    }

    public static ServiceToken bindToService(Activity context, ServiceConnection callback) {
        Activity realActivity = context.getParent();
        if (realActivity == null) {
            realActivity = context;
        }
        ContextWrapper cw = new ContextWrapper(realActivity);
        cw.startService(new Intent(cw, MediaPlaybackService.class));
        ServiceBinder sb = new ServiceBinder(callback);//ServiceBinder 是 ServiceConnection 的实现
        if (cw.bindService((new Intent()).setClass(cw, MediaPlaybackService.class), sb, 0)) {
            sConnectionMap.put(cw, sb);//缓存每一次连接，用于解绑
            return new ServiceToken(cw);//ServiceToken 标识本次绑定
        }
        Log.e("Music", "Failed to bind to service");
        return null;
    }

    public static void unbindFromService(ServiceToken token) {
        if (token == null) {
            Log.e("MusicUtils", "Trying to unbind with null token");
            return;
        }
        ContextWrapper cw = token.mWrappedContext;
        ServiceBinder sb = sConnectionMap.remove(cw);//从缓存中移除
        if (sb == null) {
            Log.e("MusicUtils", "Trying to unbind for unknown Context");
            return;
        }
        cw.unbindService(sb);
        if (sConnectionMap.isEmpty()) {
            // presumably there is nobody interested in the service at this point,
            // so don't hang on to the ServiceConnection
            sService = null;
        }
    }
```

​	其中 bind 和 unbind 在Activity 的生命周期中都会是成对出现的，unbind 时，token 用于得到 ServiceConnection 对象。

#### ServiceBinder

​	ServiceBinder 是 ServiceConnection 的实现类，用于绑定/解绑服务。同时，在每一次 bind 服务时，将根据存储设备挂载次数来判断自上次 bind 后是否发生过挂载，如果发生，则清空专辑封面的缓存。



#### ServiceToken

​	该次服务绑定的标识。

```java
    public static class ServiceToken {
        ContextWrapper mWrappedContext;
        ServiceToken(ContextWrapper context) {
            mWrappedContext = context;
        }
    }
```



### ContextWrapper

​	在启动音乐服务时，MusicUtil 使用的是以下的方式：

```java
ContextWrapper cw = new ContextWrapper(realActivity);
        cw.startService(new Intent(cw, MediaPlaybackService.class));
if (cw.bindService((new Intent()).setClass(cw, MediaPlaybackService.class), sb, 0)) {
            sConnectionMap.put(cw, sb);
            return new ServiceToken(cw);
        }
```

​	 一开始很奇怪为什么不直接使用 realActivity.startService，而是“多此一举”，知道后来注意到下面的 sConnectionMap才明白，cw 作为了 HashMap 的 key 来使用同时还用于构造 ServiceToken，所以猜测这里的作用是为了防止 realActivity 为 null。 



### API

#### onContentChanged

​	onContentChanged() 是 Activity 的一个回调方法，当布局改动时，即 setContentView() 或 addContentView() 方法执行完后将回调，可以在此进行 findViewById()。



#### setVolumeControlStream

​	Activity 的 setVolumeControlStream()用于建议硬件音量控制的音频流。



#### getLastNonConfigurationInstance

​	获取从 onRetainNonConfigurationInstance() 中返回的未配置的实例数据。



