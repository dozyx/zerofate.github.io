---
title: Dagger 官方用户指导阅读笔记
tags:
  - dagger
date: 2017-08-06 15:37:22
categories: 笔记
---

> Dagger，匕首。Dagger 1由 square 公司创建，Dagger 2 是其早期版本的一个改编，由 Google 维护。

> 本文是个人阅读官方指导时的一些记录，因为初次接触 CDI 框架，很多地方理解得不够透彻，所以有些地方做出了省略。此记录仅用于个人整体把握 dagger2 用法，如果需要深入学习（包括个人），建议参考更多文章和实际例子。

​	Dagger 可以作为一些 FactoryFactory 类如BarcodeDecoderFactory、CameraServiceLoader、MutableContextWrapper 等的替代，它实现了依赖注入设计模式，而不需要编写样板。通过构建在标准 javax.inject 注解上，每个类都很容易测试。



## Dagger2 不同之处

​	具有多种配置、注入 API 的依赖注入框架已存在多年，但Dagger 2 是第一个用生成代码实现完整 stack 的。它的指导原则是生成模仿用户可能硬编码的代码，以确保依赖注入尽量简单、可追踪和高性能。



## Dagger 使用

下面将通过一个咖啡制作器的构建来展示依赖注入和 Dagger。[coffee example](https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee)



### 声明依赖

​	Dagger 使用 @Inject 来注解用来创建该类实例的构造函数。当请求一个新实例时，Dagger将获取所需的参数值并调用此构造函数。

```java
class Thermosiphon implements Pump {
  private final Heater heater;

  @Inject
  Thermosiphon(Heater heater) {
    this.heater = heater;
  }

  ...
}
```

​	Dagger 可以直接注入字段，在此例子中，它为 heater 字段获取一个 Heater 实例，为 pump 字段获取一个 Pump 实例。

```java
class CoffeeMaker {
  @Inject Heater heater;
  @Inject Pump pump;

  ...
}
```

​	如果一个类有 @Inject 字段，但没有 @Inject 构造函数，Dagger 仍会在请求时注入这些字段，但不会创建新的实例。

​	Dagger 还支持方法注入，但通常用得更多的是构造函数注入和字段注入。



### 满足依赖

​	Dagger 默认通过上述方式来构造请求类型的实例来满足依赖，当请求一个 CoffeeMaker 时，将通过调用 new CoffeeMaker() 并设置它的注入字段来获取一个实例。

​	但是，@Inject 并不能用于每一个地方：

+ interface 无法构造
+ 第三方类无法被注解
+ 可配置（configurable）对象必须被配置（？）



​	对于 @Inject 不足够或者尴尬的情况，使用 @Provides 注解来满足依赖。方法的返回类型定义了它满足哪一个依赖。

​	例如，当需要 Heater 时，将调用 provideHeater()：

```java
@Provides static Heater provideHeater() {
  return new ElectricHeater();
}
```

​	@Provides 方法也可以拥有自身的依赖：

```java
@Provides static Pump providePump(Thermosiphon pump) {
  return pump;
}
```

​	所有的 @Provides 方法必须属于一个 module：

```java
@Module
class DripCoffeeModule {
  @Provides static Heater provideHeater() {
    return new ElectricHeater();
  }

  @Provides static Pump providePump(Thermosiphon pump) {
    return pump;
  }
}
```

​	习惯上，@Provides 方法会以 provide 前缀进行命名，module 类则以Module 后缀命名。



### 构建 graph

​	@Inject 和 @Provide 将构成由它们的 dependency 连接而成的object  graph，而 Dagger 2 使用一个 interface 来访问此 graph，该 interface 带有无参方法，并且该方法返回的是希望得到的类型。通过 @Component 对这样的 interface 进行注解并传入 module 类型，Dagger 2 将生成一个针对合约的完整实现。

```java
@Component(modules = DripCoffeeModule.class)
interface CoffeeShop {
  CoffeeMaker maker();
}
```

​	 该实现的名称由 interface 名加上 Dagger 前缀组成，对该实现调用 builder() 方法并使用返回的 builder 来设置 dependency 和 build()，这样就可以获取到一个实例。

```java
CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
    .dripCoffeeModule(new DripCoffeeModule())
    .build();
```

​	 注意，如果 @Component 不是一个顶级的 type，生成的 component 的名称将包括它外部类的名称和下划线，如：

```java
class Foo {
  static class Bar {
    @Component
    interface BazComponent {}
  }
}
```

​	生成的 component 名为 DaggerFoo_Bar_BazComponent。

​	如果所有的 dependency 均不需要用户创建 dependency 实例就可以构造，那么生成的实现将有一个 create() 方法，这样不需要处理 builder就可以获取一个新实例。

```java
public class CoffeeApp {
  public static void main(String[] args) {
    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
    coffeeShop.maker().brew();
  }
}
```



#### graph 中的绑定

​	上面的例子展示了如何使用一些更经典的绑定来构造一个 component，除此之外，还有许多用于绑定到 graph 的不同机制。下面的这些均可用于 dependency 并可能用于生成一个形成良好的 component：

+ 被 @Component.modules 直接引用或通过 @Module.includes 传递的 @Module 中使用 @Provides 声明的方法。
+ unscoped 且带有 @Inject 构造函数或者带有 @Scope 注解并匹配 component 的其中一个作用域的任何 type。（这个不是很理解）
+ component 的 dependencies 中的 provision 方法
+ component 自身
+ subcomponent 中的无限定 builder
+ 任意上述 binding 的 Provider 或 Lazy 封装
+ 任意上述 binding 的 Lazy 的 Provider（如 Provider\<Lazy\<CoffeeMaker>）
+ 任意 type 的 MembersInjector



### singleton 和 scoped 的绑定

​	用 @Singleton 来注解一个 @Provides 方法或者可注入类，这样 graph 将为所有的客户端使用该值的单一实例。

```java
@Provides @Singleton static Heater provideHeater() {
  return new ElectricHeater();
}
```

​	为了声明一个 component 与给定的 scope 关联，只需要对该 component 接口使用 scope 注解。

```java
@Component(modules = DripCoffeeModule.class)
@Singleton
interface CoffeeShop {
  CoffeeMaker maker();
}
```

​	

### 可复用的 scope

​	@Reusable 用于需要复用，但又不介意多个实例的情形。

```java
@Reusable // It doesn't matter how many scoopers we use, but don't waste them.
class CoffeeScooper {
  @Inject CoffeeScooper() {}
}

@Module
class CashRegisterModule {
  @Provides
  @Reusable // DON'T DO THIS! You do care which register you put your cash in.
            // Use a specific scope instead.
  static CashRegister badIdeaCashRegister() {
    return new CashRegister();
  }
}

@Reusable // DON'T DO THIS! You really do want a new filter each time, so this
          // should be unscoped.
class CoffeeFilter {
  @Inject CoffeeFilter() {}
}
```



### 可释放引用

​	在内存压力下，可能需要及时释放 scoped 对象。

```java
@Documented
@Retention(RUNTIME)
@CanReleaseReferences
@Scope
public @interface MyScope {}
```

​	在确定 GC 时删除 scope 中对象时，可以注入一个 ReleasableReferenceManager 对象并调用 releaseStrongReferences()，它将使 component 持有该对象的弱引用而不是强引用。

```java
@Inject @ForReleasableReferences(MyScope.class)
ReleasableReferenceManager myScopeReferenceManager;

void lowMemory() {
  myScopeReferenceManager.releaseStrongReferences();
}
```

​	如果内存压力解除，还可以还原为强引用

```java
void highMemory() {
  myScopeReferenceManager.restoreStrongReferences();
}
```



### Lazy 注入

​	Lazy\<T> 将在第一次调用 get() 方法时才进行实例化，如果 T 是一个单例，那么每一次将获得同一实例。

```java
class GrindingCoffeeMaker {
  @Inject Lazy<Grinder> lazyGrinder;

  public void brew() {
    while (needsGrinding()) {
      // Grinder created once on first call to .get() and cached.
      lazyGrinder.get().grind();
    }
  }
}
```



### Provider 注入

​	Provider\<T> 在每一次使用 get() 时为 T 调用绑定逻辑，如果绑定逻辑是一个 @Inject 的构造函数，那么将创建一个新实例，但 @Provides 将无此保证。

```java
class BigCoffeeMaker {
  @Inject Provider<Filter> filterProvider;

  public void brew(int numberOfPots) {
  ...
    for (int p = 0; p < numberOfPots; p++) {
      maker.addFilter(filterProvider.get()); //new filter every time.
      maker.addCoffee(...);
      maker.percolate();
      ...
    }
  }
}
```



### Qualifiers

​	有时候，单独的 type 是不足以标识一个 dependency 的，这种情况下就需要添加一个 qualifier 注解，@Named 就是一个 qualifier 注解。type 和 qualifier 将共同标识该 dependency。

```java
class ExpensiveCoffeeMaker {
  @Inject @Named("water") Heater waterHeater;
  @Inject @Named("hot plate") Heater hotPlateHeater;
  ...
}
```

​	通过注解对应的 @Provides 方法提供限定的值：

```java
@Provides @Named("hot plate") static Heater provideHotPlateHeater() {
  return new ElectricHeater(70);
}

@Provides @Named("water") static Heater provideWaterHeater() {
  return new ElectricHeater(93);
}
```



### 可选的绑定

​	如果希望一个 binding 即使在一些依赖没有绑定到 component 的情况下也能正常工作，可以为 module 添加一个 @BindsOptionalOf 方法。

```java
@BindsOptionalOf abstract CoffeeCozy optionalCozy();
```

​	这意味着 @Inject 构造函数、成员和 @Provides 方法可以依赖于 Optional\<CoffeeCozy> 对象，如果在 component 中有 CoffeeCozy 的绑定，那么 Optional 将存在，否则不存在。

​	也可以使用 Guava 的 Optional 或者 Java 8 的 Optional。



### 绑定实例

​	使用 @BindsInstance 将实例注入到 component 中。

```java
@Component(modules = AppModule.class)
interface AppComponent {
  App app();

  @Component.Builder
  interface Builder {
    @BindsInstance Builder userName(@UserName String userName);
    AppComponent build();
  }
}
```

```java
public static void main(String[] args) {
  if (args.length > 1) { exit(1); }
  App app = DaggerAppComponent
      .builder()
      .userName(args[0])
      .build()
      .app();
  app.run();
}
```

[dagger](https://google.github.io/dagger/)

[Youtube - DAGGER 2 - A New Type of dependency injection](https://www.youtube.com/watch?v=oK_XtfXPkqw)

[Dagger2图文完全教程](http://www.jianshu.com/p/708a3e957cf8)

[都是套路——Dagger2没有想象的那么难](http://www.jianshu.com/p/47c7306b2994)
​	