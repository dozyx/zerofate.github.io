---
title: 设置里的输入法选择
tags:
  - android
  - 输入法
date: 2017-05-24 15:37:22
categories: 笔记
---

> 主要源码位置 \src\com\android\settings\inputmethod\InputMethodAndLanguageSettings.java

概念

+ 输入法 subtype：可以描述区域(如 en_US、fr_FR...) 、模式(如语音、键盘)，并可用于 IME 开关和设置。InputMethodSubtype 类用于指定 IME 所包含的 subtype 的元信息。

### 默认输入法选择

输入法选择对话框是通过 framework 创建的，InputMethodAndLanguageSettings中对应代码为

```java
final InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
imm.showInputMethodPicker(false /* showAuxiliarySubtypes */);
```

false 表示不显示辅助输入法，该方法为 @hide。旧版本 API 只有无参方法（不是 @hide）。

showInputMethodPicker 最后调用的是 InputMethodManagerService 类里的showInputMethodMenuInternal() 方法

```java
    private void showInputMethodMenuInternal(boolean showSubtypes) {	

        final Context context = mContext;
        final boolean isScreenLocked = isScreenLocked();

        //mSettings 是 InputMethodSettings 类的一个对象，而InputMethodSettings
      	//是 InputMethodUtils 里的一个内部类
        final String lastInputMethodId = mSettings.getSelectedInputMethod();//实际是从数据库里读取
        int lastInputMethodSubtypeId = mSettings.getSelectedInputMethodSubtypeId(lastInputMethodId);

        synchronized (mMethodMap) {
            final HashMap<InputMethodInfo, List<InputMethodSubtype>> immis =
                    mSettings.getExplicitlyOrImplicitlyEnabledInputMethodsAndSubtypeListLocked(
                            mContext);
            if (immis == null || immis.size() == 0) {
                return;
            }

            hideInputMethodMenuLocked();//先隐藏

            final List<ImeSubtypeListItem> imList =
                    mSwitchingController.getSortedInputMethodAndSubtypeListLocked(
                            showSubtypes, mInputShown, isScreenLocked);//获得所有可用输入法

            if (lastInputMethodSubtypeId == NOT_A_SUBTYPE_ID) {
                final InputMethodSubtype currentSubtype = getCurrentInputMethodSubtypeLocked();
                if (currentSubtype != null) {
                    final InputMethodInfo currentImi = mMethodMap.get(mCurMethodId);
                    lastInputMethodSubtypeId = InputMethodUtils.getSubtypeIdFromHashCode(
                            currentImi, currentSubtype.hashCode());
                }
            }

            final int N = imList.size();
            mIms = new InputMethodInfo[N];
            mSubtypeIds = new int[N];
            int checkedItem = 0;
          	//找出当前选择的输入法
            for (int i = 0; i < N; ++i) {
                final ImeSubtypeListItem item = imList.get(i);
                mIms[i] = item.mImi;
                mSubtypeIds[i] = item.mSubtypeId;
                if (mIms[i].getId().equals(lastInputMethodId)) {
                    int subtypeId = mSubtypeIds[i];
                    if ((subtypeId == NOT_A_SUBTYPE_ID)
                            || (lastInputMethodSubtypeId == NOT_A_SUBTYPE_ID && subtypeId == 0)
                            || (subtypeId == lastInputMethodSubtypeId)) {
                        checkedItem = i;
                    }
                }
            }

          	//接下来是创建输入法选择框
            final Context settingsContext = new ContextThemeWrapper(context,
                    com.android.internal.R.style.Theme_DeviceDefault_Settings);

            mDialogBuilder = new AlertDialog.Builder(settingsContext);
            mDialogBuilder.setOnCancelListener(new OnCancelListener() {
                @Override
                public void onCancel(DialogInterface dialog) {
                    hideInputMethodMenu();
                }
            });

            final Context dialogContext = mDialogBuilder.getContext();
            final TypedArray a = dialogContext.obtainStyledAttributes(null,
                    com.android.internal.R.styleable.DialogPreference,
                    com.android.internal.R.attr.alertDialogStyle, 0);
            final Drawable dialogIcon = a.getDrawable(
                    com.android.internal.R.styleable.DialogPreference_dialogIcon);
            a.recycle();

            mDialogBuilder.setIcon(dialogIcon);

            final LayoutInflater inflater = (LayoutInflater) dialogContext.getSystemService(
                    Context.LAYOUT_INFLATER_SERVICE);
            final View tv = inflater.inflate(
                    com.android.internal.R.layout.input_method_switch_dialog_title, null);
          	//自定义了对话框标题的布局，布局中还包含了物理按键开关的布局
            mDialogBuilder.setCustomTitle(tv);

            // Setup layout for a toggle switch of the hardware keyboard
            mSwitchingDialogTitleView = tv;
            mSwitchingDialogTitleView
                    .findViewById(com.android.internal.R.id.hard_keyboard_section)
                    .setVisibility(mWindowManagerService.isHardKeyboardAvailable()
                            ? View.VISIBLE : View.GONE);
            final Switch hardKeySwitch = (Switch) mSwitchingDialogTitleView.findViewById(
                    com.android.internal.R.id.hard_keyboard_switch);
            hardKeySwitch.setChecked(mShowImeWithHardKeyboard);
            hardKeySwitch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
                @Override
                public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                    mSettings.setShowImeWithHardKeyboard(isChecked);
                    // Ensure that the input method dialog is dismissed when changing
                    // the hardware keyboard state.
                    hideInputMethodMenu();
                }
            });

          	//添加输入法选择
            final ImeSubtypeListAdapter adapter = new ImeSubtypeListAdapter(dialogContext,
                    com.android.internal.R.layout.input_method_switch_item, imList, checkedItem);
            final OnClickListener choiceListener = new OnClickListener() {
                @Override
                public void onClick(final DialogInterface dialog, final int which) {
                    synchronized (mMethodMap) {
                        if (mIms == null || mIms.length <= which || mSubtypeIds == null
                                || mSubtypeIds.length <= which) {
                            return;
                        }
                        final InputMethodInfo im = mIms[which];
                        int subtypeId = mSubtypeIds[which];
                        adapter.mCheckedItem = which;
                        adapter.notifyDataSetChanged();
                        hideInputMethodMenu();
                        if (im != null) {
                            if (subtypeId < 0 || subtypeId >= im.getSubtypeCount()) {
                                subtypeId = NOT_A_SUBTYPE_ID;
                            }
                          	//设置选择的输入法
                            setInputMethodLocked(im.getId(), subtypeId);
                        }
                    }
                }
            };
            mDialogBuilder.setSingleChoiceItems(adapter, checkedItem, choiceListener);

          	//设置button
            if (showSubtypes && !isScreenLocked) {
                final OnClickListener positiveListener = new OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int whichButton) {
                        showConfigureInputMethods();//这里会通过Intent启动输入设置Activity
                      //原生设置里声明了响应的Activity：.inputmethod.InputMethodAndSubtypeEnablerActivity
                      //只有勾选的输入法才可用
                    }
                };
                mDialogBuilder.setPositiveButton(
                        com.android.internal.R.string.configure_input_methods, positiveListener);
            }
            mSwitchingDialog = mDialogBuilder.create();
            mSwitchingDialog.setCanceledOnTouchOutside(true);
            mSwitchingDialog.getWindow().setType(
                    WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
            mSwitchingDialog.getWindow().getAttributes().privateFlags |=
                    WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
            mSwitchingDialog.getWindow().getAttributes().setTitle("Select input method");
            updateImeWindowStatusLocked();
            mSwitchingDialog.show();
        }
    }
```

上面代码的一些细节因为没有对输入法有很深研究，所以并没有完全弄懂。。。不过之所以看这部分代码的原因是要修改对话框的UI，所以主要的还是对话框的创建。不过因为这部分代码是在framework里的，所以并不想直接修改，于是尝试一下其他方法来更改选择输入法的弹框。



#### “选择输入法”对话框样式修改

[How can I get a list of all the Input Methods (and their names) that are installed on the phone?](https://stackoverflow.com/questions/4210086/how-can-i-get-a-list-of-all-the-input-methods-and-their-names-that-are-install)

**个人认为最好是在 framework 直接修改对话框**，不过由于个人不想动framework层，所以尝试了以下修改方式。

先获得可用的输入法信息，然后获取名称

```java
final InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(
       Context.INPUT_METHOD_SERVICE);
List<InputMethodInfo> methodInfos = imm.getEnabledInputMethodList();
for (InputMethodInfo info : methodInfos) {
   Log.d(TAG, "ime == " + info.loadLabel(getActivity().getPackageManager()).toString());
}
```

在某机器测试打印结果

```shell
D/LanguageAndInputMethodS: ime == 谷歌拼音输入法
D/LanguageAndInputMethodS: ime == Android 键盘 (AOSP)
```

从结果来看，貌似还是可以用的，在选择后。不过也存在一个问题，就是需要设置过可用的输入法才是可用的，即需要使用“选择输入法”对话框下面的“设置输入法”进行设置。

“设置输入法”按钮调用 showConfigureInputMethods() 方法打开了一个设置 Activity

```
    private void showConfigureInputMethods() {
        Intent intent = new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
                | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        mContext.startActivityAsUser(intent, null, UserHandle.CURRENT);
    }
```

响应的 Activity 是原生设置中InputMethodAndSubtypeEnablerActivity，而该 Activity 的主要操作放在了 InputMethodAndSubtypeEnabler 的 fragment中。



切换到选择的输入法

在“选择输入法”中选择后，调用了 InputMethodManagerService 里的 setInputMethodLocked(String id, int subtypeId) 方法，该方法是一个package方法，在源码中也没找到可以直接外部调用的方式，其中的代码也没能完全理解，但跟踪到最后，发现默认输入法修改的方式是通过设置数据库实现的，它调用了InputMethodUtils内部类 InputMethodSettings 的putSelectedInputMethod 方法

```java
public void putSelectedInputMethod(String imeId) {
      Settings.Secure.putStringForUser(
           mResolver, Settings.Secure.DEFAULT_INPUT_METHOD, imeId, mCurrentUserId);
}
```

该写入要求系统权限。所以，这就可以通过前面获取的InputMethodInfo的getId来修改数据库。这种方式比较简略，没有涉及subtype，也不清楚其缺陷，所以要慎用，以后有时间和有必要的话，需要进一步研究setInputMethodLocked里的具体操作。

