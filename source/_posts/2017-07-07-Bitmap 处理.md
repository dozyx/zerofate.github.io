---
title: Bitmap 的处理
tags:
  - android
  - bitmap
date: 2017-07-07 15:37:22
categories: 笔记
---

[Handling Bitmaps](https://developer.android.com/topic/performance/graphics/index.html)

[Loading Large Bitmaps Efficiently](https://developer.android.com/topic/performance/graphics/load-bitmap.html)

 [Android高效加载大图、多图解决方案，有效避免程序OOM](http://blog.csdn.net/guolin_blog/article/details/9316683)

​	为什么在 Android 中加载 bitmap 是棘手的：

+ bitmap 很容易耗尽应用的内存
+ 从 UI 线程中加载 bitmap 会降低 app 的性能
+ 如果 app 需要加载多个 bitmap 到内存中，需要巧妙地管理内存和磁盘缓存。否则，会影响到 app 界面的响应和流畅



​	大部分情况下，推荐使用 Glide 库来获取、解码和显示 bitmap。当然，也可以直接使用Android framework 中低级的 API 来处理，以下内容将介绍如何使用这些 API 来进行处理。



## 高效加载大图

​	大多数情况下，图片的大小会大于 UI 所要求的大小，在这种情况下，我们需要加载到内存中的，是一个低分辨率版本的图片。



### 读取 bitmap 尺寸和类型

​	**BitmapFactory** 类提供了从不同来源中创建 Bitmap 的多个解码方法(如decodeByteArray(), decodeFile(), decodeResource()) 。这些方法将试图为要构建的 bitmap 分配内存，因此将很容易导致 OutOfMemory 异常。每个类型的 decode 方法都有一个通过 **BitmapFactory.Options** 类指定解码配置的 signatures。在 decode 时将 inJustDecodeBounds 属性设为 true ，decoder 将返回 null (即没有 bitmap)，但 out... 字段(outWidth, outHeight, outMimeType)仍然会被设置，通过这种方法就可以在 bitmap 被构建(内存被分配)之前读取图片数据的尺寸和类型。

```java
BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);
int imageHeight = options.outHeight;
int imageWidth = options.outWidth;
String imageType = options.outMimeType;
```



### 将按比例缩小的版本加载到内存

​	在知道图片的尺寸之后，就可以确定是加载完整的图片还是加载一个副本版本。在做出决定时，需要考虑以下几个因素：

+ 估算加载完整图片所需要的内存
+ 应用可用于加载该 image 的总内存量
+ image 将要加载到的 ImageView 或其他 UI 组件的尺寸
+ 当前设备的屏幕大小和密度




​	为告诉 decoder 为 iamge 创建 subsample(将更小的版本加载到内存中)，可以在 BitmapFactory.Options 对象中将 inSampleSize 设置为 true。

​	例如，一个分辨率为 2048x1536 的 iamge，使用 inSampleSize 为 4 进行解码后得到的 bitmap 大小大概为 512x384。将此图片进行加载将使用 0.75 MB 而不是完整加载时的 12MB(假设使用的 bitmap 配置是 ARGB_8888)。

​	下面的方法基于目标宽高来计算一个 sample 大小的 2 次幂值（假如设置的 inSampleSize 不是 2 的幂，系统在使用也也会进行向下舍入来获得一个 2 的幂次方值）

```java
public static int calculateInSampleSize(
            BitmapFactory.Options options, int reqWidth, int reqHeight) {
    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if (height > reqHeight || width > reqWidth) {

        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and keeps both
        // height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) >= reqHeight
                && (halfWidth / inSampleSize) >= reqWidth) {
            inSampleSize *= 2;
        }
    }

    return inSampleSize;
}
```

​	在使用此方法时，需要先将 inJustDecodeBounds 设置为 true 来进行解码，然后将 BitmapFactory.Options 对象传入。最后将 inJustDecodeBounds 设置为 false，并使用新的 inSampleSize 值来重新解码。

```java
public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
        int reqWidth, int reqHeight) {

    // First decode with inJustDecodeBounds=true to check dimensions
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);

    // Calculate inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    // Decode bitmap with inSampleSize set
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}
```



## Bitmap 缓存

​	内存和磁盘缓存可以使组件快速重新加载已处理过的 iamge。

### 使用内存缓存

​	LruCache 类特别适用于缓存 bitmap 任务。它可以将最近引用的对象保存在一个强引用的 LinkedHashMap 中，并在缓存超出设计大小时驱逐最近最少使用的成员。

​	在为 LruCache 选择合适大小时，需要考虑一系列因素，如：

+ 应用的可用内存是多少？
+ 一次性显示在屏幕上的 image 有多少？需要有多少可用的 image 准备显示在屏幕上？
+ 设备的屏幕大小和密度是多少？一个超高密度屏幕需要更大的缓存来维持相同数目的图片。
+ 图片的尺寸和配置是多少？由此得到的每张图片应该占用的多少内存？
+ 图片访问的频率如何？是否有图片会更为频繁地被访问？如果是这样，则可能需要使这些项常驻内存或者为不同组的图片使用多个 LruCache 对象。
+ 是否能维持好数量和质量的平衡？有时候，存储大量低质量的图片，而在另一个后台任务中加载高质量版本会更为高效。



​	示例：

```java
private LruCache<String, Bitmap> mMemoryCache;

@Override
protected void onCreate(Bundle savedInstanceState) {
    ...
    // Get max available VM memory, exceeding this amount will throw an
    // OutOfMemory exception. Stored in kilobytes as LruCache takes an
    // int in its constructor.
    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);

    // Use 1/8th of the available memory for this memory cache.
    final int cacheSize = maxMemory / 8;

    mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            // The cache size will be measured in kilobytes rather than
            // number of items.
            return bitmap.getByteCount() / 1024;
        }
    };
    ...
}

public void addBitmapToMemoryCache(String key, Bitmap bitmap) {
    if (getBitmapFromMemCache(key) == null) {
        mMemoryCache.put(key, bitmap);
    }
}

public Bitmap getBitmapFromMemCache(String key) {
    return mMemoryCache.get(key);
}
```

​	示例中，为缓存分配的内存为应用内存的八分之一，对于一个 hdpi 的设备至少为 4 MB。一个全屏的 GridView 在以 800x400 分辨率的图片填充满设备大概会使用将近 1.5 MB (800*400\*4 字节)内存。因此，在内存中至少会缓存大概 2.5 页的图片。

​	将图片载入 ImageView 时，LruCache 会先被检查。如果发现存在条目，将会立即被用来更新 ImageView，否则就启动后台线程来处理图片：

```java
public void loadBitmap(int resId, ImageView imageView) {
    final String imageKey = String.valueOf(resId);

    final Bitmap bitmap = getBitmapFromMemCache(imageKey);
    if (bitmap != null) {
        mImageView.setImageBitmap(bitmap);
    } else {
        mImageView.setImageResource(R.drawable.image_placeholder);
        BitmapWorkerTask task = new BitmapWorkerTask(mImageView);
        task.execute(resId);
    }
}
```

​	BitmapWorkerTask 需要进行更新和添加条目到内存缓存

```java
class BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {
    ...
    // Decode image in background.
    @Override
    protected Bitmap doInBackground(Integer... params) {
        final Bitmap bitmap = decodeSampledBitmapFromResource(
                getResources(), params[0], 100, 100));
        addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);
        return bitmap;
    }
    ...
}
```



### 使用磁盘缓存

​	内存缓存可以有效加快最近查看图片的访问，但是并不能只依赖于缓存中可用的图片。如 GridView 等组件在使用大量数据集时可以很轻易地将内存缓存填满。应用也可能在因为中断(如来电)而处于后台时被杀死，从而导致缓存被销毁。这样当用户恢复可见时，应用还是需要对每个图片进行处理。

​	磁盘缓存可用于以上情形，来持久化处理过的图片，这样就可以在内存缓存不可用时减少加载时间。

​	以下代码除了已有的内存缓存外，还添加磁盘缓存，其中的 DiskLruCache 来自[Android source](https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/DiskLruCache.java)。

```java
private DiskLruCache mDiskLruCache;
private final Object mDiskCacheLock = new Object();
private boolean mDiskCacheStarting = true;
private static final int DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MB
private static final String DISK_CACHE_SUBDIR = "thumbnails";

@Override
protected void onCreate(Bundle savedInstanceState) {
    ...
    // Initialize memory cache
    ...
    // Initialize disk cache on background thread
    File cacheDir = getDiskCacheDir(this, DISK_CACHE_SUBDIR);
    new InitDiskCacheTask().execute(cacheDir);
    ...
}

class InitDiskCacheTask extends AsyncTask<File, Void, Void> {
    @Override
    protected Void doInBackground(File... params) {
        synchronized (mDiskCacheLock) {
            File cacheDir = params[0];
            mDiskLruCache = DiskLruCache.open(cacheDir, DISK_CACHE_SIZE);
            mDiskCacheStarting = false; // Finished initialization
            mDiskCacheLock.notifyAll(); // Wake any waiting threads
        }
        return null;
    }
}

class BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {
    ...
    // Decode image in background.
    @Override
    protected Bitmap doInBackground(Integer... params) {
        final String imageKey = String.valueOf(params[0]);

        // Check disk cache in background thread
        Bitmap bitmap = getBitmapFromDiskCache(imageKey);

        if (bitmap == null) { // Not found in disk cache
            // Process as normal
            final Bitmap bitmap = decodeSampledBitmapFromResource(
                    getResources(), params[0], 100, 100));
        }

        // Add final bitmap to caches
        addBitmapToCache(imageKey, bitmap);

        return bitmap;
    }
    ...
}

public void addBitmapToCache(String key, Bitmap bitmap) {
    // Add to memory cache as before
    if (getBitmapFromMemCache(key) == null) {
        mMemoryCache.put(key, bitmap);
    }

    // Also add to disk cache
    synchronized (mDiskCacheLock) {
        if (mDiskLruCache != null && mDiskLruCache.get(key) == null) {
            mDiskLruCache.put(key, bitmap);
        }
    }
}

public Bitmap getBitmapFromDiskCache(String key) {
    synchronized (mDiskCacheLock) {
        // Wait while disk cache is started from background thread
        while (mDiskCacheStarting) {
            try {
                mDiskCacheLock.wait();
            } catch (InterruptedException e) {}
        }
        if (mDiskLruCache != null) {
            return mDiskLruCache.get(key);
        }
    }
    return null;
}
// 创建特定应用的缓存目录，先尝试使用外部存储，但如为挂载，则使用内置存储
// Creates a unique subdirectory of the designated app cache directory. Tries to use external
// but if not mounted, falls back on internal storage.
public static File getDiskCacheDir(Context context, String uniqueName) {
    // Check if media is mounted or storage is built-in, if so, try and use external cache dir
    // otherwise use internal cache dir
  	// 如果存储设备已挂载或者不可移除，则使用外部缓存目录，否则使用内置缓存目录
    final String cachePath =
            Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
                    !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :
                            context.getCacheDir().getPath();

    return new File(cachePath + File.separator + uniqueName);
}
```


### 配置变更(Configuration Changes)处理

​	如果 Fragment 调用了 setRetainInstance(true) ，那么在 Activity 重建时，内存缓存将可以保留。

​	示例代码：

```java
private LruCache<String, Bitmap> mMemoryCache;

@Override
protected void onCreate(Bundle savedInstanceState) {
    ...
    RetainFragment retainFragment =
            RetainFragment.findOrCreateRetainFragment(getFragmentManager());
    mMemoryCache = retainFragment.mRetainedCache;
    if (mMemoryCache == null) {
        mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {
            ... // Initialize cache here as usual
        }
        retainFragment.mRetainedCache = mMemoryCache;
    }
    ...
}

class RetainFragment extends Fragment {
    private static final String TAG = "RetainFragment";
    public LruCache<String, Bitmap> mRetainedCache;

    public RetainFragment() {}

    public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) {
        RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG);
        if (fragment == null) {
            fragment = new RetainFragment();
            fm.beginTransaction().add(fragment, TAG).commit();
        }
        return fragment;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }
}
```



## Bitmap 内存管理

[Managing Bitmap Memory](https://developer.android.com/topic/performance/graphics/manage-memory.html)

​	实际使用例子可以在官方的 Demo—— DisplayingBitmaps 看到。

> ​	Android 3.0+ 版本与更低版本的处理方式不同，因为暂时未用到，只大致浏览了一下。

​	首先，需要了解 Android 中 bitmap 内存管理的发展：

+ 在 Android 2.2 及之前的版本中，当发生 GC 时，app 的线程将被停止，这样会导致性能的降低。而 2.3 添加了一个并发的 GC，内存将在 bitmap 不再被引用时回收。
+ 在 Android 2.3 及之前的版本中，bitmap 的背景像素数据被保存在本地内存(native memory)中，它与存储在 Dalvik 堆中的 bitmap 自身是独立分离的。本地内存中像素数据以不可预测的方式释放，这将可能导致应用短暂的内存限制和崩溃。从 Android 3.0 开始，像素数据与相应的 bitmap 一起存储在 Dalvik 堆中。



### Android 2.3.3 及更低版本的内存管理

​	推荐使用 Bitmap 的 recycle() 方法。

> 注意：只能在确保 bitmap 不会再被调用时使用 recycle()，如果在调用了 recycle() 后在绘制该 bitmap 将发生错误。

