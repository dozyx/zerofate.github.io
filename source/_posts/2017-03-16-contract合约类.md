---
title: Android 数据库里的 contract 合约类
tags:
  - android
date: 2017-03-16 15:37:22
categories: 笔记
---

[Contract Classes](http://developer.android.com/guide/topics/providers/content-provider-basics.html#ContractClasses)

[Android 内容提供器---创建内容提供器（实现合约类）](https://www.oschina.net/question/565065_74874)

[What is a Contract Class and how is it used](http://stackoverflow.com/questions/9243361/what-is-a-contract-class-and-how-is-it-used)

​	Contract Classes（合约类）是一个`public final`类，包含了content URI、列名、intent action及其他特性的常量定义，这些常量可以方便我们使用content provider，它也可以包含静态的辅助方法来操作URI。合约类由provider的开发者定义，并提供给其他开发者。

+ contract class在content provider和其他应用间建立了一个合约；
+ 常量名称方便开发者使用正确的常量（列名或者URI）
+ 有助于制作javadoc

  ​**示例：**

  ​User Dictionary Provider有一个合约类UserDictionary，它包含了content URI和列名常量。如指向“words”表的content URI定义在常量` UserDictionary.Words.CONTENT_URI`中。一个查询projection可以使用如下的定义：

```java
String[] mProjection =
{
    UserDictionary.Words._ID,
    UserDictionary.Words.WORD,
    UserDictionary.Words.LOCALE
};
```



UserDictionary类源码：

```java
public class UserDictionary {

    /** Authority string for this provider. */
    public static final String AUTHORITY = "user_dictionary";

    /**
     * The content:// style URL for this provider
     */
    public static final Uri CONTENT_URI =
        Uri.parse("content://" + AUTHORITY);

    private static final int FREQUENCY_MIN = 0;
    private static final int FREQUENCY_MAX = 255;

    /**
     * Contains the user defined words.
     */
    public static class Words implements BaseColumns {
        /**
         * The content:// style URL for this table
         */
        public static final Uri CONTENT_URI =
                Uri.parse("content://" + AUTHORITY + "/words");

        /**
         * The MIME type of {@link #CONTENT_URI} providing a directory of words.
         */
        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/vnd.google.userword";

        /**
         * The MIME type of a {@link #CONTENT_URI} sub-directory of a single word.
         */
        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/vnd.google.userword";

        public static final String _ID = BaseColumns._ID;

        /**
         * The word column.
         * <p>TYPE: TEXT</p>
         */
        public static final String WORD = "word";

        /**
         * The frequency column. A value between 1 and 255. Higher values imply higher frequency.
         * <p>TYPE: INTEGER</p>
         */
        public static final String FREQUENCY = "frequency";

        /**
         * The locale that this word belongs to. Null if it pertains to all
         * locales. Locale is as defined by the string returned by Locale.toString().
         * <p>TYPE: TEXT</p>
         */
        public static final String LOCALE = "locale";

        /**
         * The uid of the application that inserted the word.
         * <p>TYPE: INTEGER</p>
         */
        public static final String APP_ID = "appid";

        /**
         * An optional shortcut for this word. When the shortcut is typed, supporting IMEs should
         * suggest the word in this row as an alternate spelling too.
         */
        public static final String SHORTCUT = "shortcut";

        /**
         * @deprecated Use {@link #addWord(Context, String, int, String, Locale)}.
         */
        @Deprecated
        public static final int LOCALE_TYPE_ALL = 0;

        /**
         * @deprecated Use {@link #addWord(Context, String, int, String, Locale)}.
         */
        @Deprecated
        public static final int LOCALE_TYPE_CURRENT = 1;

        /**
         * Sort by descending order of frequency.
         */
        public static final String DEFAULT_SORT_ORDER = FREQUENCY + " DESC";

        /** Adds a word to the dictionary, with the given frequency and the specified
         *  specified locale type.
         *
         *  @deprecated Please use
         *  {@link #addWord(Context, String, int, String, Locale)} instead.
         *
         *  @param context the current application context
         *  @param word the word to add to the dictionary. This should not be null or
         *  empty.
         *  @param localeType the locale type for this word. It should be one of
         *  {@link #LOCALE_TYPE_ALL} or {@link #LOCALE_TYPE_CURRENT}.
         */
        @Deprecated
        public static void addWord(Context context, String word,
                int frequency, int localeType) {

            if (localeType != LOCALE_TYPE_ALL && localeType != LOCALE_TYPE_CURRENT) {
                return;
            }

            final Locale locale;

            if (localeType == LOCALE_TYPE_CURRENT) {
                locale = Locale.getDefault();
            } else {
                locale = null;
            }

            addWord(context, word, frequency, null, locale);
        }

        /** Adds a word to the dictionary, with the given frequency and the specified
         *  locale type.
         *
         *  @param context the current application context
         *  @param word the word to add to the dictionary. This should not be null or
         *  empty.
         *  @param shortcut optional shortcut spelling for this word. When the shortcut
         *  is typed, the word may be suggested by applications that support it. May be null.
         *  @param locale the locale to insert the word for, or null to insert the word
         *  for all locales.
         */
        public static void addWord(Context context, String word,
                int frequency, String shortcut, Locale locale) {
            final ContentResolver resolver = context.getContentResolver();

            if (TextUtils.isEmpty(word)) {
                return;
            }

            if (frequency < FREQUENCY_MIN) frequency = FREQUENCY_MIN;
            if (frequency > FREQUENCY_MAX) frequency = FREQUENCY_MAX;

            final int COLUMN_COUNT = 5;
            ContentValues values = new ContentValues(COLUMN_COUNT);

            values.put(WORD, word);
            values.put(FREQUENCY, frequency);
            values.put(LOCALE, null == locale ? null : locale.toString());
            values.put(APP_ID, 0); // TODO: Get App UID
            values.put(SHORTCUT, shortcut);

            Uri result = resolver.insert(CONTENT_URI, values);
            // It's ok if the insert doesn't succeed because the word
            // already exists.
        }
    }
}
```