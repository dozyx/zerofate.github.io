---
title: 线程基本知识
tags:
  - java
date: 2017-05-01 15:37:22
categories: 笔记
---

> 并发“具有可论证的确定性，但是实际上具有不可确定性”。——《Thinking In Java》

## 基本的线程机制

### 基本使用

+  使用Runnable定义任务

   ```java
   /**
   * 一段发射倒计时代码
   */
   public class LiftOff implements Runnable {
      protected int countDown = 10;
      private static int taskCount = 0;
      private final int id = taskCount++;

      public LiftOff() {
      }

      public LiftOff(int countDown) {
          this.countDown = countDown;
      }

      public String status() {
          return "#" + id + "(" + (countDown > 0 ? countDown : "LiftOff!" )+ "), ";
      }

      @Override
      public void run() {
          while (countDown-- > 0) {
              System.out.print(status());
              Thread.yield();
              //yield是对线程调度器的一种建议，它在声明"我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机"
          }
      }
   }
   ```
  ```

+ 将Runable对象附加到Thread上

  ```java
  public class MainThread {
      public static void main(String[] args) {
          for (int i = 0; i < 5; i++) {
              new Thread(new LiftOff()).start();
          }
          System.out.print("Waiting for LiftOff");
      }
  }
  ```

上面代码运行的一个输入为：

```
#1(9), #0(9), #2(9), Waiting for LiftOff#3(9), #4(9), #1(8), #2(8), #0(8), #4(8), #0(7), #2(7), #0(6), #1(7), #3(8), #0(5), #3(7), #0(4), #2(6), #4(7), #2(5), #0(3), #3(6), #1(6), #3(5), #0(2), #3(4), #0(1), #2(4), #4(6), #3(3), #1(5), #2(3), #0(LiftOff!), #3(2), #4(5), #2(2), #1(4), #4(4), #3(1), #4(3), #1(3), #2(1), #4(2), #3(LiftOff!), #4(1), #2(LiftOff!), #1(2), #4(LiftOff!), #1(1), #1(LiftOff!), 
```

该结果每次运行结果可能都会不同，如果将Runable中的Thread.yield()注释掉，还会出现连续打印同一线程的情况。



### 使用Execulor

[Executor](https://developer.android.com/reference/java/util/concurrent/Executor.html)

​	Executor 执行器用于管理 Thread 对象，从而简化并发编程。 执行器的作用在于调度任务的执行。

#### Executor

​	Executor 是一个 interface，用于执行提交的 Runnable 任务。Executor 只提供了一个抽象方法：

```java
void execute(Runnable command);
```

​	Executor 可用来替代显示创建 thread 方式，如

```java
Executor executor = anExecutor();
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
...
```

​	Executor 并不强制要求异步使用，如最简单的方式：

```java
 class DirectExecutor implements Executor {
   public void execute(Runnable r) {
     r.run();
   }
 }
```

​	但更普遍的，任务会在其他线程执行：

```java
 class ThreadPerTaskExecutor implements Executor {
   public void execute(Runnable r) {
     new Thread(r).start();
   }
 }
```

​	许多 Executor 的实现会对如何、何时调度任务添加一些限制。如下面的执行器将串行执行提交的任务：

```java
 class SerialExecutor implements Executor {
   final Queue<Runnable> tasks = new ArrayDeque<>();
   final Executor executor;
   Runnable active;

   SerialExecutor(Executor executor) {
     this.executor = executor;
   }

   public synchronized void execute(final Runnable r) {
     tasks.add(new Runnable() {
       public void run() {
         try {
           r.run();
         } finally {
           scheduleNext();
         }
       }
     });
     if (active == null) {
       scheduleNext();
     }
   }

   protected synchronized void scheduleNext() {
     if ((active = tasks.poll()) != null) {
       executor.execute(active);//递归方式依次执行任务
     }
   }
 }
```

#### Executors

​	该类定义了多个工厂和工具方法，包括以下几类：

+ 创建和返回一个以常用有用配置进行设置的 `ExecutorService`
+ 创建和返回一个以常用有用配置进行设置的`ScheduledExecutorService` 
+ 创建和返回一个"wrapped"的 ExecutorService，它将通过使特定实现方法无法访问来禁用再配置。
+ 创建和返回一个 ThreadFactory ，它可用于将新建线程设置为已知的状态。
+ 创建和返回一个 `Callable` ，可在需要Callable 的执行方法中使用。




#### ExecutorService

[ExecutorService](https://developer.android.com/reference/java/util/concurrent/ExecutorService.html)

​	ExecutorService 是一个接口类，它继承了 Executor。ExecutorService 提供了终止管理的方法和可以为一个或多个异步任务的进展情况生成 Future 的方法。

​	ExecutorService 可以被关闭，这将导致它拒绝新的任务。`shutdown()`允许先前提交的任务在终止前执行；而`shutdownNow()`将阻止等待的任务开始并试图将当前执行的任务停止。在终止时，executor 将没有任务在执行，没有任务在等待执行，也没有任务会被提交。

​	ExecutorService 方法说明：

+ `boolean awaitTermination(long timeout, TimeUnit unit)`

  在 shutdown 请求发出后，阻塞直到所有任务执行完毕或发生超时，又或者当前线程被中断。

+ `<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)`

+ `<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)`

  执行传入的任务，并在所有任务完成或者超时时返回包含了它们的状态和结果的 Future 列表

+ `<T> T invokeAny(Collection<? extends Callable<T>> tasks)`

+ `<T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)`

  执行传入的任务，并返回一个任务成功完成（没有抛出异常且在超时前）的结果。在正常或发生 exception 返回时，没有完成的任务将被取消。

+ `boolean isShutdown();`

  executor 是否已关闭

+ `boolean isTerminated();`

  所有任务是否已在shut down 后完成。注意：该方法只在 shutdown() 或 shutdownNow() 调用后才会返回true。

+ `void shutdown();`

  对先前提交的已被执行的任务启动一个有序的 shutdown，新的任务将不再被接受。该方法不会等待先前提交的任务执行完成，如果需要等待，使用`awaitTermination`。

+ `List<Runnable> shutdownNow();`

  尝试停止所有运行的任务，阻止等待的任务，并返回一系列正在等待执行的任务。该方法不会等待已经执行的任务执行完成，如果需要等待，使用`awaitTermination`。

+ `<T> Future<T> submit(Callable<T> task);`

  提交一个具有返回值的任务并执行。成功执行完成后，通过Future.get方法可返回任务的结果。

+ `<T> Future<T> submit(Runnable task, T result);`

+ `Future<?> submit(Runnable task);`



示例1：

```java
class NetworkService implements Runnable {
   private final ServerSocket serverSocket;
   private final ExecutorService pool;

   public NetworkService(int port, int poolSize)
       throws IOException {
     serverSocket = new ServerSocket(port);
     pool = Executors.newFixedThreadPool(poolSize);//poolSize池中的线程数
   }

   public void run() { // run the service
     try {
       for (;;) {
         pool.execute(new Handler(serverSocket.accept()));
       }
     } catch (IOException ex) {
       pool.shutdown();
     }
   }
 }

 class Handler implements Runnable {
   private final Socket socket;
   Handler(Socket socket) { this.socket = socket; }
   public void run() {
     // read and service request on socket
   }
 }
```

示例2：

下面代码将分两个阶段来关闭一个 ExecutorService，先使用shutdown来拒绝新的任务，然后在必要时调用shutdownNow来取消拖延的任务

```java
 void shutdownAndAwaitTermination(ExecutorService pool) {
   pool.shutdown(); // Disable new tasks from being submitted
   try {
     // Wait a while for existing tasks to terminate
     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
       pool.shutdownNow(); // Cancel currently executing tasks
       // Wait a while for tasks to respond to being cancelled
       if (!pool.awaitTermination(60, TimeUnit.SECONDS))
           System.err.println("Pool did not terminate");
     }
   } catch (InterruptedException ie) {
     // (Re-)Cancel if current thread also interrupted
     pool.shutdownNow();
     // Preserve interrupt status
     Thread.currentThread().interrupt();
   }
 }
```



部分通过Executors 静态方法返回的 ExecutorService 实现：

- newCachedThreadPool

  创建一个线程池，在需要时将创建新的线程，但会在先前的线程可用的情况进行复用

- newFixedThreadPool

  限制线程数量，一次性预先执行代价高昂的线程分配

- newSingleThreadScheduledExecutor

  相当于线程数量为1的FixedThreadPool，提交的任务将排队执行



#### 从任务中产生返回值

​	Runnable 不返回任何值，如果需要在任务完成时能够返回一个值，可以实现 Callable 接口而不是 Runnable 接口。**Callable 必须使用 ExecutorService.submit() 方法调用**。

```java
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

​	示例：

```java
class TaskWithResult implements Callable<String> {
    private int id;
    public TaskWithResult(int id) {
        this.id = id;
    }
    @Override
    public String call() throws Exception {
        return "result of TaskWIthResult " + id;
    }
}
public class CallableDemo {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        ArrayList<Future<String>> results = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            results.add(exec.submit(new TaskWithResult(i)));
        }
        for (Future<String> fs:
        results){
            try {
                //get() 会阻塞直到结果准备就绪
                System.out.println(fs.get());
            } catch (InterruptedException e) {
                System.out.println(e);
            } catch (ExecutionException e) {
                System.out.println(e);
            } finally {
                exec.shutdown();
            }
        }
    }
}
```

​	打印结果

```
result of TaskWIthResult 0
result of TaskWIthResult 1
result of TaskWIthResult 2
result of TaskWIthResult 3
result of TaskWIthResult 4
result of TaskWIthResult 5
result of TaskWIthResult 6
result of TaskWIthResult 7
result of TaskWIthResult 8
result of TaskWIthResult 9
```



### 休眠

​	调用 sleep() 将使任务中止执行指定的时间。

旧风格：

`Thread.sleep(100);`

Java SE 5/6风格：

`TimeUnit.MILLISECONDS.sleep(100);`



### 优先级

​	线程的优先级将该线程的重要性传递给了调度器。优先级不会导致死锁，**优先级较低的线程仅仅是执行的效率较低**。在绝大多数时间里，所有线程都应该以默认的优先级运行，试图操纵线程优先级通常是一种错误。

​	`Thread.currentThread()`获取驱动任务的 Thread 对象的引用，`setPriority()`修改优先级，`getPriority()`读取现有线程的优先级。

​	JDK 里有10个优先级，但它与多数操作系统都不能映射得很好，比如，windows 有7个优先级且不是固定了，所以这种映射关系也是不确定的。唯一可移植的方法是当调整优先级的时候，只使用 MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY。



### 让步

​	当调用`yield()` 时，也是在建议具有相同优先级的其他线程可以运行，不过这只是一个暗示，没有任何机制保证它将会被采纳。



### 后台（daemon）线程

​	在线程启动前，调用 `setDaemon()` 设置后台线程，这种线程并不属于程序中不可或缺的部分。

​	可以使用 ThreadFactory 接口创建线程：

```java
public interface ThreadFactory {
    /**
     * Constructs a new {@code Thread}.  Implementations may also initialize
     * priority, name, daemon status, {@code ThreadGroup}, etc.
     *
     * @param r a runnable to be executed by new thread instance
     * @return constructed thread, or {@code null} if the request to
     *         create a thread is rejected
     */
    Thread newThread(Runnable r);
}
```

​	如下的实现将所有线程设置为后台状态：

```java
class SimpleThreadFactory implements ThreadFactory {
  	public Thread newThread(Runnable r) {
      	Thread t = new Thread(r);
      	t.setDaemon(true);
      	return t;
    }
}}
```

​	后台线程创建的子线程也是后台线程，即使没有显式设置。










