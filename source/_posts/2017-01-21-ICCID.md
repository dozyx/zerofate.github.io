---
title: ICCID 基本知识
tags:
  - android
date: 2017-01-21 15:37:22
categories: 笔记
---

[theiphonewiki iccid](https://www.theiphonewiki.com/wiki/ICCID)

[百度百科 iccid](http://baike.baidu.com/link?url=uZuUqG4T0x5PGR5ICzUz4rYwlHxHyo9ptXmL7D8Y3dHkppUvjg36zV-mICeAmDWP4s6kGZKOV_1a4SyjA71mtK)

完整的ICCID为19到20字符，前六位为运营商代码，中国移动898600，898602；中国联通：898601、898609；中国电信：898603、898606。

### 格式

`MMCC IINN NNNN NNNN NN C x`

MM：主要行业标识符，89表示电信管理部门和私营运营机构（Telecommunications administrations and private operating agencies）

CC：国家编码（如：86 = China）

II：发卡方标识符

N{12}：账户ID（SIM号码）

C：使用Luhn算法对其他19位数字进行计算得到的校验位

x：==一个额外的第20位，'AT!ICCID?'命令返回，并不是ICCID的正式部分==



### 中国运营商编码规则

#### 中国移动

898600MFSSYYGXXXXXXP
89： 国际编号
86： 国家编号，86：中国
00： 运营商编号，00：中国移动
M： 号段，对应用户号码前3位
0：159 1：158 2：150
3：151 4-9：134-139 A：157
B：188 C：152 D：147 E：187
F： 用户号码第4位
SS： 省编号
（北京01 天津02 河北03 山西04 内蒙古05 辽宁06 吉林07
黑龙江08 上海09 江苏10 浙江11 安徽12 福建13 江西14
山东15 河南16 湖北17 湖南18 广东19 广西20 海南21
四川22 贵州23 云南24 西藏25 陕西26 甘肃27 青海28
宁夏29 新疆30 重庆31）
YY： 编制ICCID时年号的后两位
G： SIM卡供应商代码
0：雅斯拓 1：GEMPLUS 2：武汉天喻 3：江西捷德 4：珠海东信和平
5：大唐微电子通 6：航天九州通 7：北京握奇 8：东方英卡
9：北京华虹 A ：上海柯斯
X…X： 用户识别码
P： 校验位

#### 中国联通

898601YY8SSXXXXXXXXP
89： 国际编号
86： 国家编号，86：中国
01： 运营商编号，01：中国联通
YY： 编制ICCID时年号的后两位
8： 中国联通ICCID默认此为为8
SS：2位省份编码
（10内蒙古 11北京 13天津 17山东 18河北 19山西 30安徽 31上海 34江苏
36浙江 38福建 50海南 51广东 59广西 70青海 71湖北 74湖南 75江西
76河南 79西藏 81四川 83重庆 84陕西 85贵州 86云南 87甘肃 88宁夏
89新疆 90吉林 91辽宁 97黑龙江
X…X： 卡商生产的顺序编码）
P： 校验位

#### 中国电信

898603YYXMHHHXXXXXXP
89：国际编号
86：国家编号，86：中国
03：运营商编号，03：中国电信
YY：编制ICCID时的年号（取后两位），如‘09’代表2009年
M ：保留位，固定为0
HHH：本地网地区代码，位数不够前补零。如上海区号为021，则HHH为'021’；长沙区号为0731，则HHH为‘731’，测试卡代码为001
XXXXXXP：7位流水号，建议前2位作为批次号



### Luhn algorithm（模10算法）

[wiki](https://en.wikipedia.org/wiki/Luhn_algorithm)

[百度百科](http://baike.baidu.com/link?url=cuNZmNSYlx5QRQmmDSnQTrHGjtKfZJh9SEDYDGYBq7s7gSZQ2HC5bH4pM6f4tCUV3kg7e8OjE758yUW2cFQPYq)

luhn算法或luhn公式，也被称为"modulus 10"或"mod 10"算法（模10算法）。它是一种简单的校验公式，一般会被用于身份证号码，IMEI号码，美国供应商识别号码，或是加拿大的社会保险号码的验证。

> 它的目的不是成为一种加密安全的哈希函数；它的目的是防止意外出现的错误，而不是恶意攻击。



#### 算法描述

1. 从==最右边==的数字（校验位）开始，向左每第二个数字乘以2，如果乘以2后的值大于2则将数字位相加（如16：1 + 6 = 7）或者减去9（如16：16 - 9 = 7）
2. 把所有数字相加,得到总和
3. 如果数字是合法的，总和将可以被10整除

如：

| Account number     | 7    | 9      | 9    | 2     | 7    | 3     | 9    | 8      | 7    | 1     | **x** |      |
| ------------------ | ---- | ------ | ---- | ----- | ---- | ----- | ---- | ------ | ---- | ----- | ----- | ---- |
| Double every other | 7    | **18** | 9    | **4** | 7    | **6** | 9    | **16** | 7    | **2** | **x** |      |
| Sum digits         | 7    | **9**  | 9    | 4     | 7    | 6     | 9    | **7**  | 7    | 2     | **x** |      |

总和为67+x，校验位x通过计算无校验位的总和然后乘以9除以10取余得到（67 X 9 mod 10），完整计算：

1. 计算无校验位总和（67）
2. 乘以9（603）
3. 得到个位数3为校验位

另一种计算方法：

1. 无校验总和（67）
2. 取个位数7
3. 10减去个位数
4. 3为校验位



#### 优缺点

​	Luhn 算法会检测到任何单码的错误以及几乎所有的相邻数字换位的错误。但是它不会检测两个数字序列09转90的错误（反之亦然）。它会检测到十分之七的相同双位数错误（不会检测到22和55的互换，33和66的互换，44和77的互换）。其他更复杂的检查数字算法，如费尔赫夫算法，可以检测出更多的转录错误。模N的Luhn算法是Luhn算法的一个扩展，支持非数字字符串。因为该算法采取了从右向左的方式，而且零位会影响计算的结果。只有当零位造成了数位的移动或是用零来填充一串数字的开头时才不会影响计算结果的生成。因此不论在将1234用零填充为0001234之前或是之后，使用Luhn算法得到的结果都是一样的。

### 校验网站

[链接](http://www.ee.unb.ca/cgi-bin/tervo/luhn.pl?N=89860316442000407597)



### 查看方式

iphone手机：设置 -> 通用 ->关于本机







