---
title: 原生设置里的 wifi 设置源码分析
tags:
  - android
  - wifi
date: 2017-04-21 15:37:22
categories: 笔记
---

Android 7.1.1

> 源码位置：platform_packages_apps_settings/src/com/android/settings/wifi



## WifiSettings

​	WifiSettings 是设置中 wifi  的主要类，它是 PreferenceFragment的一个间接子类。在原生设置中，PreferenceFragment引用的布局与默认的有一点差别，在布局开头多了一个 id 为 pinned_header 的 FrameLayout。

### 连接（submit）

> 可能为连接或保存

对话框点击 submit 按钮，将会在 WifiSettings 设置的监听中处理，实际调用了 submit(...) 方法

*WifiSettings*

```java
    /* package */ void submit(WifiConfigController configController) {
 
        final WifiConfiguration config = configController.getConfig();
 
        if (config == null) {
          	//config 为null，表示没有配置新的 WifiConfiguration，如果该网络为已配置网络，则直接连接
            if (mSelectedAccessPoint != null
                    && mSelectedAccessPoint.isSaved()) {
                connect(mSelectedAccessPoint.getConfig());
            }
        } else if (configController.getMode() == WifiConfigUiBase.MODE_MODIFY) {
            // 如果是 modify 模式，只对配置进行保存，不会自动连接
            mWifiManager.save(config, mSaveListener);
        } else {
          	// 其余情况，将对配置进行保存，然后再连接
          	// 先进行save，如果网络在之前已配置，则会更新配置
            mWifiManager.save(config, mSaveListener);
            if (mSelectedAccessPoint != null) { // Not an "Add network"
                connect(config);
            }
        }
 
        mWifiTracker.resumeScanning();
    }
```

*WifiConfigController*

```java
    /* package */ WifiConfiguration getConfig() {
        if (mMode == WifiConfigUiBase.MODE_VIEW) {
          	//view 模式不会编辑任何内容，只是显示一些信息，将直接返回
            return null;
        }
 
        WifiConfiguration config = new WifiConfiguration();
 
        if (mAccessPoint == null) {
          	//手动添加网络
            config.SSID = AccessPoint.convertToQuotedString(
                    mSsidView.getText().toString());
            // If the user adds a network manually, assume that it is hidden.
            config.hiddenSSID = true;
        } else if (!mAccessPoint.isSaved()) {
            config.SSID = AccessPoint.convertToQuotedString(
                    mAccessPoint.getSsidStr());
        } else {
          	//已配置的网络可以直接根据 networkId 进行连接
            config.networkId = mAccessPoint.getConfig().networkId;
        }
 
        config.shared = mSharedCheckBox.isChecked();
 
        switch (mAccessPointSecurity) {
            case AccessPoint.SECURITY_NONE:
            	//安全性为无
                config.allowedKeyManagement.set(KeyMgmt.NONE);
                break;
 
            case AccessPoint.SECURITY_WEP:
            	//安全性为WEP
                config.allowedKeyManagement.set(KeyMgmt.NONE);
                config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
                config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
                if (mPasswordView.length() != 0) {
                    int length = mPasswordView.length();
                    String password = mPasswordView.getText().toString();
                    // WEP-40, WEP-104, and 256-bit WEP (WEP-232?)
                    if ((length == 10 || length == 26 || length == 58)
                            && password.matches("[0-9A-Fa-f]*")) {
                      	//密钥为16进制时不需要加双引号
                        config.wepKeys[0] = password;
                    } else {
                        config.wepKeys[0] = '"' + password + '"';
                    }
                }
                break;
 
            case AccessPoint.SECURITY_PSK:
            	// 安全性为 PSK
                config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
                if (mPasswordView.length() != 0) {
                    String password = mPasswordView.getText().toString();
                    if (password.matches("[0-9A-Fa-f]{64}")) {
                        config.preSharedKey = password;
                    } else {
                        config.preSharedKey = '"' + password + '"';
                    }
                }
                break;
 
            case AccessPoint.SECURITY_EAP:
                //eap验证
            	...
                break;
            default:
                return null;
        }
 
        config.setIpConfiguration(
                new IpConfiguration(mIpAssignment, mProxySettings,
                                    mStaticIpConfiguration, mHttpProxy));//Ip 代理设置
 
        return config;
    }
```

### 忘记

*WifiSettings*

```java
/* package */ void forget() {
        MetricsLogger.action(getActivity(), MetricsEvent.ACTION_WIFI_FORGET);
        if (!mSelectedAccessPoint.isSaved()) {
            if (mSelectedAccessPoint.getNetworkInfo() != null &&
                    mSelectedAccessPoint.getNetworkInfo().getState() != State.DISCONNECTED) {
                // Network is active but has no network ID - must be ephemeral.
              	// 禁用 ephemeral 网络
                mWifiManager.disableEphemeralNetwork(
                        AccessPoint.convertToQuotedString(mSelectedAccessPoint.getSsidStr()));
            } else {
                // Should not happen, but a monkey seems to trigger it
                Log.e(TAG, "Failed to forget invalid network " + mSelectedAccessPoint.getConfig());
                return;
            }
        } else {
          	//已保存网络直接根据 networkId 忘记
            mWifiManager.forget(mSelectedAccessPoint.getConfig().networkId, mForgetListener);
        }
 
        mWifiTracker.resumeScanning();
 
        // We need to rename/replace "Next" button in wifi setup context.
        changeNextButtonState(false);
    }
```



### 上下文菜单

根据接入点网络的状态，菜单项会不同。最多会有四个动作：连接、忘记、修改、写入nfc

*WifiSettings*

```java
    @Override
    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo info) {
            Preference preference = (Preference) view.getTag();
 
            if (preference instanceof LongPressAccessPointPreference) {
                mSelectedAccessPoint =
                        ((LongPressAccessPointPreference) preference).getAccessPoint();
              	//将网络名称作为标题
                menu.setHeaderTitle(mSelectedAccessPoint.getSsid());
                if (mSelectedAccessPoint.isConnectable()) {//接入点可连接
                  	//“连接到网络”
                    menu.add(Menu.NONE, MENU_ID_CONNECT, 0, R.string.wifi_menu_connect);
                }
 
                WifiConfiguration config = mSelectedAccessPoint.getConfig();
                // Some configs are ineditable
              	//配置不可修改，将直接返回
                if (isEditabilityLockedDown(getActivity(), config)) {
                    return;
                }
 				//可对保存的或者短暂的网络进行忘记操作
                if (mSelectedAccessPoint.isSaved() || mSelectedAccessPoint.isEphemeral()) {
                    // Allow forgetting a network if either the network is saved or ephemerally
                    // connected. (In the latter case, "forget" blacklists the network so it won't
                    // be used again, ephemerally).
                  	//“取消保存网络”
                    menu.add(Menu.NONE, MENU_ID_FORGET, 0, R.string.wifi_menu_forget);
                }
              	//可对已保存网络进行修改操作
                if (mSelectedAccessPoint.isSaved()) {
                  	//"修改网络"
                    menu.add(Menu.NONE, MENU_ID_MODIFY, 0, R.string.wifi_menu_modify);
                    NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());
                    if (nfcAdapter != null && nfcAdapter.isEnabled() &&
                            mSelectedAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE) {
                        // Only allow writing of NFC tags for password-protected networks.
                      	//“写入nfc标签”
                        menu.add(Menu.NONE, MENU_ID_WRITE_NFC, 0, R.string.wifi_menu_write_to_nfc);
                    }
                }
            }
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        if (mSelectedAccessPoint == null) {
            return super.onContextItemSelected(item);
        }
        switch (item.getItemId()) {
            case MENU_ID_CONNECT: {
                if (mSelectedAccessPoint.isSaved()) {
                    connect(mSelectedAccessPoint.getConfig());// 已保存，直接连接
                } else if (mSelectedAccessPoint.getSecurity() == AccessPoint.SECURITY_NONE) {
                    /** Bypass dialog for unsecured networks */
                    mSelectedAccessPoint.generateOpenNetworkConfig();
                    connect(mSelectedAccessPoint.getConfig());//无密码，生成配置后连接
                } else {
                  	//其他需要填写配置
                    showDialog(mSelectedAccessPoint, WifiConfigUiBase.MODE_CONNECT);
                }
                return true;
            }
            case MENU_ID_FORGET: {
                forget();
                return true;
            }
            case MENU_ID_MODIFY: {
                showDialog(mSelectedAccessPoint, WifiConfigUiBase.MODE_MODIFY);
                return true;
            }
            case MENU_ID_WRITE_NFC:
                showDialog(WRITE_NFC_DIALOG_ID);
                return true;
 
        }
        return super.onContextItemSelected(item);
    }
```



## wifi对话框

### 接入点点击事件

```java
//WifiSettings.java
	@Override
    public boolean onPreferenceTreeClick(Preference preference) {
      	//LongPressAccessPointPreference 添加了长按支持，用于显示上下文菜单
        if (preference instanceof LongPressAccessPointPreference) {
            mSelectedAccessPoint = ((LongPressAccessPointPreference) preference).getAccessPoint();
            if (mSelectedAccessPoint == null) {
                return false;
            }
            /** Bypass dialog for unsecured, unsaved, and inactive networks */
          	//单独处理不安全、未保存且不活跃的网络
            if (mSelectedAccessPoint.getSecurity() == AccessPoint.SECURITY_NONE &&
                    !mSelectedAccessPoint.isSaved() && !mSelectedAccessPoint.isActive()) {
                mSelectedAccessPoint.generateOpenNetworkConfig();//生成开放网络配置
                connect(mSelectedAccessPoint.getConfig());//连接，实际调用的是WifiManager的connect方法
            } else if (mSelectedAccessPoint.isSaved()) {
                showDialog(mSelectedAccessPoint, WifiConfigUiBase.MODE_VIEW);
            } else {
                showDialog(mSelectedAccessPoint, WifiConfigUiBase.MODE_CONNECT);
            }
        } else if (preference == mAddPreference) {
            onAddNetworkPressed();//在扫描到的接入点后面有一个手动添加网络，点击后同样会打开对话框，
          				//对话框UI样式为WifiConfigUiBase.MODE_CONNECT，但mSelectedAccessPoint为null
        } else {
            return super.onPreferenceTreeClick(preference);
        }
        return true;
    }
	...
      
    private void showDialog(AccessPoint accessPoint, int dialogMode) {
        if (accessPoint != null) {
            WifiConfiguration config = accessPoint.getConfig();
            if (isEditabilityLockedDown(getActivity(), config) && accessPoint.isActive()) {
              //锁定无法修改，没理解是什么条件
                RestrictedLockUtils.sendShowAdminSupportDetailsIntent(getActivity(),
                        RestrictedLockUtils.getDeviceOwner(getActivity()));
                return;
            }
        }
 
        if (mDialog != null) {
            removeDialog(WIFI_DIALOG_ID);
            mDialog = null;
        }
 
        // Save the access point and edit mode
        mDlgAccessPoint = accessPoint;
        mDialogMode = dialogMode;
 
        showDialog(WIFI_DIALOG_ID);
    }
	...
    //onCreateDialog 是实际创建对话框的地方
	@Override
    public Dialog onCreateDialog(int dialogId) {
        switch (dialogId) {
            case WIFI_DIALOG_ID:
                AccessPoint ap = mDlgAccessPoint; // For manual launch
                if (ap == null) { // For re-launch from saved state
                    if (mAccessPointSavedState != null) {
                        ap = new AccessPoint(getActivity(), mAccessPointSavedState);
                      	//mAccessPointSavedState 是一个Bundle对象，用于保存屏幕方向变化前的状态
                        // For repeated orientation changes
                        mDlgAccessPoint = ap;
                        // Reset the saved access point data
                        mAccessPointSavedState = null;
                    }
                }
                // If it's null, fine, it's for Add Network
                mSelectedAccessPoint = ap;
            	//WifiDialog传入的参数为 Context，按钮点击事件监听器，对应的AccessPoint，对话框模式、
            	//是否隐藏submit按钮（此处直接设为false）
                mDialog = new WifiDialog(getActivity(), this, ap, mDialogMode,
                        /* no hide submit/connect */ false);
                return mDialog;
            case WPS_PBC_DIALOG_ID:
                ...
            case WPS_PIN_DIALOG_ID:
                ...
            case WRITE_NFC_DIALOG_ID:
                ...
        }
        return super.onCreateDialog(dialogId);
    }
```

### 对话框

​	wifi对话框对应的类为 WifiDialog，但实际逻辑在 WifiConfigController 类中处理，WifiDialog 实现了WifiConfigUiBase 接口，该接口定义了一些UI相关的方法。

```java
public interface WifiConfigUiBase {
 
    /**
     * Viewing mode for a Wi-Fi access point. Data is displayed in non-editable mode.
     */
    int MODE_VIEW = 0;
    /**
     * Connect mode. Data is displayed in editable mode, and a connect button will be shown.
     */
    int MODE_CONNECT = 1;
    /**
     * Modify mode. All data is displayed in editable fields, and a "save" button is shown instead
     * of "connect". Clients are expected to only save but not connect to the access point in this
     * mode.
     */
    int MODE_MODIFY = 2;
 
    public Context getContext();
    public WifiConfigController getController();
    public LayoutInflater getLayoutInflater();
    public int getMode();
 
    public void dispatchSubmit();
 
    public void setTitle(int id);
    public void setTitle(CharSequence title);
 
    public void setSubmitButton(CharSequence text);
    public void setForgetButton(CharSequence text);
    public void setCancelButton(CharSequence text);
    public Button getSubmitButton();
    public Button getForgetButton();
    public Button getCancelButton();
}
```

WifiDialog 的 UI 样式有三种：

+ WifiConfigUiBase.MODE_VIEW

  查看模式，用于已保存的网络，数据以不可编辑模式显示

+ WifiConfigUiBase.MODE_CONNECT

  连接模式：数据以可编辑模式显示，并会显示一个连接按钮

+ WifiConfigUiBase.MODE_MODIFY

  修改模式：所有数据以可编辑模式显示，并以“保存”按钮替代“连接”按钮。客户端应该仅对该接入点进行保存而不连接。

其中，modify 和 connect 两种样式的 UI 差别只在于 submit 按钮的文本，一个为保存，一个为连接。

#### 布局分析

​	WifiDialog 的布局文件是 wifi_dialog，它的根标签是一个ScrollView。将根据不同的模式显示/隐藏部分UI。

一个完整的布局包括（线性垂直排列）：

+ **信息展示**
+ 类型
  + SSID 名称编辑
  + 安全性选择：无、WEP、WPA/WPA2 PSK、802.1x EAP
+ 安全性字段：这部分属于验证部分，主要分为eap和密码两部分，但eap一般会比较少用
  + eap：eap是一种验证框架
    + “eap 方法”选择
    + “阶段 2 身份验证”选择
    + “CA 证书选择”
    + 未指定证书警告显示（没有测试到什么情况显示）
    + “域名”编辑（没测到）
    + 未指定域名警告显示（没测到）
    + “用户证书”选择（没测到）
    + “身份”编辑
    + “匿名身份”编辑
  + **密码编辑**
  + “显示密码”选项
+ “显示高级选项”
+ wifi高级字段
  + 代理方式选择：无、手动、代理自动配置
  + 使用代理警告显示
  + pac 网址编辑
  + 代理配置字段
    + 主机名编辑
    + 端口编辑
    + 不使用代理地址编辑
  + ip字段
    + IP 设置选择：DHCP、静态
  + 静态ip配置
    + IP地址编辑
    + 网关编辑
    + 网络前缀长度编辑
    + dns 域名 1 编辑
    + dns 域名 2 编辑
    + “与其他设备用户共享” 选项

#### 可连接条件分析

密码：

+ 安全性为 WEP 时，密码长度为0，则密码无效
+ 安全性为 PSK 时，密码长度小于8，则密码无效

*WifiConfigController*

```java
boolean isSubmittable() {
        boolean enabled = false;
        boolean passwordInvalid = false;//密码是否无效
 
        if (mPasswordView != null
                && ((mAccessPointSecurity == AccessPoint.SECURITY_WEP
                        && mPasswordView.length() == 0)
                    || (mAccessPointSecurity == AccessPoint.SECURITY_PSK
                           && mPasswordView.length() < 8))) {
            passwordInvalid = true;
        }
  		if ((mSsidView != null && mSsidView.length() == 0)
                || ((mAccessPoint == null || !mAccessPoint.isSaved()) && passwordInvalid)) {
            enabled = false;
        } else {
            enabled = ipAndProxyFieldsAreValid();//代理是否有效
        }
        ...
        //ssid 名称编辑和代理判断
  		...
        //eap 相关条件判断
  		...
        return enabled;
    }
```



## AccessPoint

​	每一个 AccessPoint 表示一个接入点。

### isActive()

​	连接是否活跃。活跃表示该网络已配置或者未配置的网络处于“未连接”外的状态。

```java
    /**
     * Return whether this is the active connection.
     * For ephemeral connections (networkId is invalid), this returns false if the network is
     * disconnected.
     */
    public boolean isActive() {
        return mNetworkInfo != null &&
                (networkId != WifiConfiguration.INVALID_NETWORK_ID ||
                 mNetworkInfo.getState() != State.DISCONNECTED);
    }
```



### isSaved()

​	是否为已配置网络

```
    public boolean isSaved() {
        return networkId != WifiConfiguration.INVALID_NETWORK_ID;
    }
```



### isConnectable()

是否可连接，条件为有信号，并且该网络具有可用状态

```java
    public boolean isConnectable() {
        return getLevel() != -1 && getDetailedState() == null;
    }
```

### isEphemeral()

短暂？不明白是什么意思	

```java
    public boolean isEphemeral() {
        return mInfo != null && mInfo.isEphemeral() &&
                mNetworkInfo != null && mNetworkInfo.getState() != State.DISCONNECTED;
    }
```

### generateOpenNetworkConfig()

​	为开放网络生成配置

```java
    /**
     * Generate and save a default wifiConfiguration with common values.
     * Can only be called for unsecured networks.
     */
    public void generateOpenNetworkConfig() {
        if (security != SECURITY_NONE)
            throw new IllegalStateException();
        if (mConfig != null)
            return;
        mConfig = new WifiConfiguration();
        mConfig.SSID = AccessPoint.convertToQuotedString(ssid);
        mConfig.allowedKeyManagement.set(KeyMgmt.NONE);
    }
```
















