---
title: 录音功能实现
tags:
  - android
  - media
date: 2017-02-10 15:37:22
categories: 笔记
---

**参考**

《Apress.Android.Recipes.A.Problem-Solution.Approach.for.Android.5.0.4th.Edition.2015》 4-7

《Apress.Pro.Android.Media》第七章 (此书好像是基于Android 2.2，**详细例子可以查看[配套源码](https://github.com/Apress/pro-android-media)**)

[内置录音机soundrecorder](https://github.com/android/platform_packages_apps_soundrecorder)



## 捕获音频的方式

+ Intent

  MediaStore.Audio.Media.RECORD_SOUND_ACTION

+ MediaRecorder

  结合MediaPlayer播放。（内置录音机使用的方式）

+ AudioRecord

  可录制原始音频，结合AudioTrack播放，最灵活。

后面两种需要声明权限

```java
<uses-permission android:name="android.permission.RECORD_AUDIO"/>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```

## 通过意图捕获音频

​	利用已有的、提供录制功能的应用程序来实现音频录制功能。

​	通过意图`MediaStore.Audio.Media.RECORD_SOUND_ACTION`和startActivityResult打开录音程序，onActivityResult中获得音频录制文件的URI，最后使用MediaPlayer播放。

### 创建

```java
Intent intent = new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION);
List<ResolveInfo> list = getPackageManager()
  .queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);
if (list.size() > 0) {
	startActivityForResult(intent, RECORD_REQUEST);
}
```

### 录制结束得到录音文件URI

```java
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		if (resultCode == RESULT_OK && requestCode == RECORD_REQUEST) {
			audioFileUri = data.getData();
			playRecording.setEnabled(true);
		}
	}
```

### 播放

```java
MediaPlayer mediaPlayer = MediaPlayer.create(this, audioFileUri);
mediaPlayer.setOnCompletionListener(this);
mediaPlayer.start();
```





## MediaRecorder定制音频捕获

​	MediaRecorder类可用于音频和视频捕获。

### 状态机

其状态机：

![mediarecorder_state_diagram](C:\Users\sdt13599\OneDrive\markdown\photo\media\mediarecorder_state_diagram.gif)

​	在创建MediaRecorder对象后，为捕获音频，必须调用`setAudioSource`和`setAudioEncoder`方法，在准备录制之前通常还会调用其他两个方法`setOutputFormat`和`setOutPutFile`，前者选择文件格式，后者指定目标文件。

> 每个调用的发生顺序对结果影响非常大。

### 使用

==setAudioSource== 

此方法使用AudioSource内部类常量作为参数，捕获音频一般使用的是MediaRecorder.AudioSource.MIC。

```java
MediaRecorder recorder = new MediaRecorder();
recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
```

下一个调用方法为

==setOutputFormat== 

此方法采用MediaRecorder.OutputFormat内部类中指定的常量值作为参数。音频可以选择3gp格式`MediaRecorder.OutputFormat.THREE_GPP`。

```java
recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
```

设置输出格式后，调用

==setAudioEncoder== 

设置应该使用的编解码器，可以使用MediaRecorder.AudioEncoder类中的常量。

```java
recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
```

**AMR_NB是自适应多速率窄带编解码器，这种编码解码器针对语音进行了优化，因此不适合语音之外的其他内容。**默认情况下它的采样率为8kHz，码率在4.75~12.2kbps之间，这两个数据对于录制语音之外的其他内容而言非常低。（内容基于《Android多媒体开发高级编程》一书，但此书出版时间不太清楚，可能未必符合现今的情况，但Android内置的录音机应用使用的也是此编码器）

最后，录制到指定文件可以使用

==setOutputFile==

在SD卡上存储文件

```java
File path = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/com.apress.proandroidmedia.ch07.customrecorder/files/");
path.mkdirs();//创建目录，必要的话会同时创建父级目录
try {
		audioFile = File.createTempFile("recording", ".3gp", path);
} catch (Exception e) {
}
recorder.setOutputFile(audioFile.getAbsolutePath());
```

现在可以实际地调用prepare方法，其表明配置阶段的结束，同时通知MediaRecorder准备开始录制。

```java
recorder.prepare();
recorder.start();//真正开始录制
```

#### 停止录制

```java
recorder.stop();
recorder.release();
```

​	==当activity处于paused或者stopped状态时，应对MediaRecorder对象调用release()方法。==

### 其他MediaRecorder方法

+ **getMaxAmplitude**

  允许请求由MediaRecorder录制的音频的最大振幅。每次调用此方法时都会重置该值，因此每次调用都将返回自从上一次调用以来的最大振幅。**可以通过定期调用该方法实现音量表。**

+ **setMaxDuration**

  允许以毫秒为单位指定录制的最大文件大小。必须在setOutputFormat方法之后和prepare方法之前调用该方法。

+ **setMaxFileSize**

  允许以字节为单位指定录制的最大文件大小。与setMaxDuration一样，必须在setOutputFormat方法之后和prepare方法之前调用该方法。

示例片段：显示音频输入的数字振幅

```java
	private class RecordAmplitude extends AsyncTask<Void, Integer, Void> {

		@Override
		protected Void doInBackground(Void... params) {
			while (isRecording) {
				try {
					Thread.sleep(500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				publishProgress(recorder.getMaxAmplitude());
			}
			return null;
		}

		@Override
		protected void onProgressUpdate(Integer... values) {
			amplitudeTextView.setText(values[0].toString());
		}

	}
```





## 使用AudioRecord录制原始音频

> ​	AudioRecord是3种方法中最灵活的方法（因为它允许访问原始音频流），但是它拥有最少的内置功能，如不会自动压缩音频。

### 使用

#### 构造

​	使用AudioRecord的基础知识非常简单，只需要构造一个AudioRecord类型的对象，并传入各种不同的配置参数。构造函数有

```java
 public AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat,
            int bufferSizeInBytes)
```

==audioSource==

音频源，在MediaRecorder.AudioSource中定义，录音可以使用`MediaRecorder.AudioSource.MIC`。

```java
int audioSource = MediaRecorder.AudioSource.MIC;
```

==sampleRateInHz==

采样率，单位Hz。MediaRecorder采样的音频是8kHz或8000Hz。而CD质量的音频通常是44.1kHz或44100Hz。11025是另一个常用的采样率。

```java
int sampleRateInHz = 11025;
```

==channelConfig==

音频通道的数量，在AudioFormat类中指定了用于此参数的常量。

+ AudioFormat.CHANNEL_CONFIGURATION_MONO
+ AudioFormat.CHANNEL_CONFIGURATION_STEREO
+ AudioFormat.CHANNEL_CONFIGURATION_INVALID
+ AudioFormat.CHANNEL_CONFIGURATION_DEFAULT

```java
int channelConfig = AudioFormat.CHANNEL_CONFIGURATION_MONO;//单声道配置
```

==audioFormat==

音频格式，同样定义在AudioFormat类

+ AudioFormat.ENCODING_DEFAULT
+ AudioFormat.ENCODING_INVALID
+ AudioFormat.ENCODING_PCM_16BIT
+ AudioFormat.ENCODING_PCM_8BIT

录制音频可以需安装PCM 16位和PCM 8位。PCM代表脉冲编码调制（Pulse Code Modulation），它实际上是原始的音频样本。16位将占用更多的空间和处理能力，但表示的音频将更加接近真实。

```java
int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
```

==bufferSizeInBytes==

缓冲区大小。实际上可以查询AudioRecord类以获得最小缓冲区大小，查询方式是调用getMinBufferSize静态方法。

```java
int bufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRateInHz, channelConfig,?
	audioFormat);
```



开始构造实际的AudioRecord对象

```java
AudioRecord audioRecord = new AudioRecord(audioSource, sampleRateInHz, channelConfig,?
	audioFormat, bufferSizeInBytes);
```

#### 创建文件

AudioRecord类实际上并不保存捕获的音频，因此需要手动保存捕获的音频。

创建文件

```java
File recordingFile;
File path = new File(Environment.getExternalStorageDirectory()?
.getAbsolutePath() + "/Android/data/com.apress.proandroidmedia.ch07?
.altaudiorecorder /files/");
path.mkdirs();
try {
recordingFile = File.createTempFile("recording", ".pcm", path);
} catch (IOException e1) {
throw new RuntimeException("Couldn't create file on SD card", e);
}
```

接下来将创建对应该文件的OutputStream，尤其是出于性能和便利的原因，可以将它包装在BufferedOutputStream和DataOutputStream中。

```java
DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new?
	FileOutputStream(recordingFile)));
```



#### 捕获

​	启动捕获，同时将音频样本写入到文件。可以使用short数组来保存从AudioRecord对象读取而来的音频。同时，将采用比AudioRecord对象的缓冲区更小的数组，从而在将音频读取出来之前缓冲区没有填满。除以4将使得该数组是AudioRecord对象内部缓冲区大小的一半。

```java
short[] buffer = new short[bufferSize/4];
```

​	开始录制

```java
audioRecord.startRecording();
```

​	录制开始之后可以构造一个循环，不断从AudioRecord对象读取音频并放入short数组中，同时写入对应文件的DataOutputStream。

```java
while (true) {//实际中不会使用死循环
	int bufferReadResult = audioRecord.read(buffer, 0, bufferSize/4);
	for (int i = 0; i < bufferReadResult; i++) {
		dos.writeShort(buffer[i]);
	}
}
audioRecord.stop();
dos.close();
```

### AudioTrack播放原始音频

​	AudioTrack能够播放使用AudioRecord捕获的音频，而它们并不能使用MediaPlayer对象来播放。

#### 构造

```java
public AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat,
            int bufferSizeInBytes, int mode, int sessionId)
```

==streamType==

流类型，定义在AudioManager类中的常量。音频流AudioManager.STREAM_MUSIC。

==sampleRateInHz==

采样率，使用与捕获音频相同的值。

==channelConfig==

通道配置，与构造AudioRecord对象时使用的值相同。

==audioFormat==

音频格式，与构造AudioRecord对象时使用的值相同。

==bufferSizeInBytes==

将在对象中用于存储音频的缓冲区大小。调用getMinBufferSize方法。

```java
int frequency = 11025;
int channelConfiguration = AudioFormat.CHANNEL_CONFIGURATION_MONO;
int audioEncoding = AudioFormat.ENCODING_PCM_16BIT;
int bufferSize = AudioTrack.getMinBufferSize(frequency, channelConfiguration,?
	audioEncoding);
```

==mode==

模式

+ AudioTrack.MODE_STATIC

  在播放发生之前将所有的音频数据转移到AudioTrack对象

+ AudioTrack.MODE_STREAM

  在播放的同时将音频数据持续地转移到AudioTrack对象

==sessionId==

会话Id



#### 读取

一旦构造了AudioTrack，就需要打开音频源，将音频数据读取到缓冲区中，并将它传递给AudioTrack对象。

```java
DataInputStream dis = new DataInputStream(
	new BufferedInputStream(new FileInputStream(recordingFile)));
```



#### 播放

```java
audioTrack.play();
while (isPlaying && dis.available() > 0) {
	int i = 0;
	while (dis.available() > 0 && i < audiodata.length) {
		audiodata[i] = dis.readShort();
		i++;
	}
	audioTrack.write(audiodata, 0, audiodata.length);
}
dis.close();
```



#### release

开发文档上对release()方法的说明

> Releases the native AudioRecord resources. The object can no longer be used and the reference should be set to null after a call to release()

在调用release()后还需要将对象的reference设为null。















