---
title: 非触摸输入法的一些问题
tags:
  - android
  - 输入法
date: 2016-11-14 15:37:22
categories: 笔记
---

## 无触摸屏键盘IME

### 感悟

通过实体键来操控软键盘本身就具有一定的不合理性，至少在没有成熟解决方案之前。所以，对于键盘的功能应该尽可能简单。

### 在一些EditText中输入后，输入内容被自动全选。

**复现**：EditText的inputType为password，输入法的onKeyDown返回false。该问题由于为了解决点击隐藏键后输入法自动弹出问题而将onKey处理移到了onKeyUp中引起。

继承EditText重写onKeyDown，直接返回false或true均没问题，但返回super.onKeyDown(keyCode, event)时出现问题。

**具体出现原因需要进一步分析验证，为解决该问题，将输入法的onKeyDown在键盘显示时返回true（是否会有其它问题待验证）**

在TextView的onKeyDown处理中

```
case KeyEvent.KEYCODE_DPAD_CENTER:
                if (event.hasNoModifiers()) {
                    if (shouldAdvanceFocusOnEnter()) {//此方法在singleLine或者inputType为邮件时返回true
                        return 0;
                    }
                }
                break;
..........................
..........................
        if (mEditor != null && mEditor.mKeyListener != null) {
            boolean doDown = true;
            if (otherEvent != null) {
                try {
                    beginBatchEdit();
                    final boolean handled = mEditor.mKeyListener.onKeyOther(this, (Editable) mText,
                            otherEvent);
                    hideErrorIfUnchanged();
                    doDown = false;
                    if (handled) {
                        return -1;
                    }
                } catch (AbstractMethodError e) {
                    // onKeyOther was added after 1.0, so if it isn't
                    // implemented we need to try to dispatch as a regular down.
                } finally {
                    endBatchEdit();
                }
            }

            if (doDown) {
                beginBatchEdit();
                final boolean handled = mEditor.mKeyListener.onKeyDown(this, (Editable) mText,
                        keyCode, event);
                endBatchEdit();
                hideErrorIfUnchanged();
                if (handled) return 1;
            }
        }

        // bug 650865: sometimes we get a key event before a layout.
        // don't try to move around if we don't know the layout.

        if (mMovement != null && mLayout != null) {
            boolean doDown = true;
            if (otherEvent != null) {
                try {
                    boolean handled = mMovement.onKeyOther(this, (Spannable) mText,
                            otherEvent);
                    doDown = false;
                    if (handled) {
                        return -1;
                    }
                } catch (AbstractMethodError e) {
                    // onKeyOther was added after 1.0, so if it isn't
                    // implemented we need to try to dispatch as a regular down.
                }
            }
            if (doDown) {
                if (mMovement.onKeyDown(this, (Spannable)mText, keyCode, event)) {
                    if (event.getRepeatCount() == 0 && !KeyEvent.isModifierKey(keyCode)) {
                        mPreventDefaultMovement = true;
                    }
                    return 2;
                }
            }
        }
        return mPreventDefaultMovement && !KeyEvent.isModifierKey(keyCode) ? -1 : 0;
    }
```







### 在EditText处于焦点状态，点击隐藏键隐藏输入法后，输入法又自动启动

EditText父类为TextView，在TextView的源码的onKeyUp处理中有以下代码

```java
case KeyEvent.KEYCODE_DPAD_CENTER:
                if (event.hasNoModifiers()) {
                    /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                    if (!hasOnClickListeners()) {
                        if (mMovement != null && mText instanceof Editable
                                && mLayout != null && onCheckIsTextEditor()) {
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            viewClicked(imm);
                            if (imm != null && getShowSoftInputOnFocus()) {
                                imm.showSoftInput(this, 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
```

onCheckIsTextEditor方法

```java
@Override
    public boolean onCheckIsTextEditor() {
        return mEditor != null && mEditor.mInputType != EditorInfo.TYPE_NULL;
    }
```

由于将onKey输入放在输入法的onKeyDown中处理掉，而onKeyUp中返回了false，这样，EditText将继续执行onKeyUp而重新打开了输入法（输入法的onKeyDown和onKeyUp会先于EditText的先执行）。但在将onKey移到了onKeyUp，而直接在onKeyDown中不做处理返回false时，又引发了InputType为password的EditText在输入时被自动选中的问题。