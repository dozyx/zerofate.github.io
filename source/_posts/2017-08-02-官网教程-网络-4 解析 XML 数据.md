---
title: Training - 解析 XML 数据
tags:
  - android
  - 网络
date: 2017-08-02 15:37:22
categories: 笔记
---

[Parsing XML Data](https://developer.android.com/training/basics/network-ops/xml.html#consume)

[networkusage sample](https://android.googlesource.com/platform/frameworks/base/+/master/samples/training/network-usage/src/com/example/android/networkusage) 

> 建议学习完整的 sample 示例，sample 运行时需要 url 改为 https 才能正常获取 XML 数据。该 sample 将抓取 StackOverflow 网站关于 android 主题的最新问题，并以 HTML 形式显示问题的 title、link 和 summary。

## 选择解析器(Parser)

​	推荐使用 XmlPullParser，它是一种在 Android 上解析 XML 的高效可维护的方式。

​	历史上，Android 已经有两个该接口的实现：

+ 通过 XmlPullParserFactory.newPullParser() 获取的 KXmlParser

+ 通过 Xml.newPullParser() 获取的 ExpatPullParser（在新的 Android 版本中，ExpatPullParser 好像已经被移除，通过 Xml.newPullParser 返回的同样是 KXmlParser。查看 log 是在 2011年就已经移除，但不知道原因，不过这并不影响使用，因为我们通常使用的是 XmlPullParser 接口。）

  两种方案都是很好的选择。下面例子使用的是 ExpatPullParser。



## 分析 Feed

​	feed 是网站提供的一段规范的 XML 数据。分析 feed 的第一步是确定感兴趣的字段，parser 将提取这些字段的数据，并忽略其余字段。

​	下面的例子中， feed 中每个 StackOverflow.com 的帖子都作为一个 entry 的标签，并内嵌了其他标签。

​	[feed 地址](https://stackoverflow.com/feeds/tag?tagnames=android&sort=newest)

```xml
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule" ...">
<title type="text">newest questions tagged android - Stack Overflow</title>
...
    <entry>
    ...
    </entry>
    <entry>
        <id>http://stackoverflow.com/q/9439999</id>
        <re:rank scheme="http://stackoverflow.com">0</re:rank>
        <title type="text">Where is my data file?</title>
        <category scheme="http://stackoverflow.com/feeds/tag?tagnames=android&sort=newest/tags" term="android"/>
        <category scheme="http://stackoverflow.com/feeds/tag?tagnames=android&sort=newest/tags" term="file"/>
        <author>
            <name>cliff2310</name>
            <uri>http://stackoverflow.com/users/1128925</uri>
        </author>
        <link rel="alternate" href="http://stackoverflow.com/questions/9439999/where-is-my-data-file" />
        <published>2012-02-25T00:30:54Z</published>
        <updated>2012-02-25T00:30:54Z</updated>
        <summary type="html">
            <p>I have an Application that requires a data file...</p>

        </summary>
    </entry>
    <entry>
    ...
    </entry>
...
</feed>
```



## 实例化 Parser

​	接下来的步骤是实例化一个 parser 并开始解析。下面代码片段中，parser 初始化为不处理命名空间并使用 InputStream 作为输入，它调用 nextTag() 开始解析过程并调用 readFeed() 方法来提取和处理 app 感兴趣的数据。

```java
public class StackOverflowXmlParser {
    // We don't use namespaces
    private static final String ns = null;

    public List parse(InputStream in) throws XmlPullParserException, IOException {
        try {
            XmlPullParser parser = Xml.newPullParser();
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
            parser.setInput(in, null);
            parser.nextTag();
            return readFeed(parser);
        } finally {
            in.close();
        }
    }
 ...
}
```

 

## 读取 Feed

​	readFeed() 方法执行处理 feed 的实际工作，它查找“entry”元素作为递归处理 feed 的起点，非 entry 的 tag 将忽略。当整个 feed 被递归处理完后，readFeed 返回一个包含了所有 从 feed 中提取 的entry 的 List，包括了内嵌的数据成员。

```java
private List readFeed(XmlPullParser parser) throws XmlPullParserException, IOException {
    List entries = new ArrayList();

    parser.require(XmlPullParser.START_TAG, ns, "feed");
    while (parser.next() != XmlPullParser.END_TAG) {
        if (parser.getEventType() != XmlPullParser.START_TAG) {
            continue;
        }
        String name = parser.getName();
        // Starts by looking for the entry tag
        if (name.equals("entry")) {
            entries.add(readEntry(parser));
        } else {
            skip(parser);
        }
    }
    return entries;
}
```



## 解析 XML

可以按以下步骤解析一个 XML feed：

1. 确定要在 app 中使用的 tag。例子中将提取 entry 标签数据及它的内嵌标签 title、link、summary。
2. 创建以下方法：
   + 为每个感兴趣的 tag 提供一个”read“方法。如 readEntry()、readTitle() 等。
   + 为每个不同类型的 tag 提取数据并将解析器推送到下一个标签的方法。如：
     + 对于 title 和 summary 标签，解析器调用 readText()，该方法通过调用 parser.getText() 来为这些标签提取数据
     + 对于 link 标签，解析器通过先确定 link 是否是它感兴趣的类型在为 link 提取数据。然后，它使用 parser.getAttributeValue() 来提取 link 的值。
     + 对于 entry 标签，解析器调用 readEntry()。该方法将解析 entry 的内嵌标签并返回带有 title、link和 summary 的 Entry 对象。

```java
public static class Entry {
    public final String title;
    public final String link;
    public final String summary;

    private Entry(String title, String summary, String link) {
        this.title = title;
        this.summary = summary;
        this.link = link;
    }
}

// Parses the contents of an entry. If it encounters a title, summary, or link tag, hands them off
// to their respective "read" methods for processing. Otherwise, skips the tag.
private Entry readEntry(XmlPullParser parser) throws XmlPullParserException, IOException {
    parser.require(XmlPullParser.START_TAG, ns, "entry");
    String title = null;
    String summary = null;
    String link = null;
    while (parser.next() != XmlPullParser.END_TAG) {
        if (parser.getEventType() != XmlPullParser.START_TAG) {
            continue;
        }
        String name = parser.getName();
        if (name.equals("title")) {
            title = readTitle(parser);
        } else if (name.equals("summary")) {
            summary = readSummary(parser);
        } else if (name.equals("link")) {
            link = readLink(parser);
        } else {
            skip(parser);
        }
    }
    return new Entry(title, summary, link);
}

// Processes title tags in the feed.
private String readTitle(XmlPullParser parser) throws IOException, XmlPullParserException {
    parser.require(XmlPullParser.START_TAG, ns, "title");
  	// require 测试当前事务是否匹配给定类型，命名空间和名称是否匹配。第二个参数为 namespace，这里的 ns 为 null
    String title = readText(parser);
    parser.require(XmlPullParser.END_TAG, ns, "title");
    return title;
}

// Processes link tags in the feed.
private String readLink(XmlPullParser parser) throws IOException, XmlPullParserException {
    String link = "";
    parser.require(XmlPullParser.START_TAG, ns, "link");
    String tag = parser.getName();
    String relType = parser.getAttributeValue(null, "rel");
    if (tag.equals("link")) {
        if (relType.equals("alternate")){
            link = parser.getAttributeValue(null, "href");
            parser.nextTag();
        }
    }
    parser.require(XmlPullParser.END_TAG, ns, "link");
    return link;
}

// Processes summary tags in the feed.
private String readSummary(XmlPullParser parser) throws IOException, XmlPullParserException {
    parser.require(XmlPullParser.START_TAG, ns, "summary");
    String summary = readText(parser);
    parser.require(XmlPullParser.END_TAG, ns, "summary");
    return summary;
}

// For the tags title and summary, extracts their text values.
private String readText(XmlPullParser parser) throws IOException, XmlPullParserException {
    String result = "";
    if (parser.next() == XmlPullParser.TEXT) {
        result = parser.getText();
        parser.nextTag();
    }
    return result;
}
  ...
}
```



## 忽略不关心的 tag

```java
private void skip(XmlPullParser parser) throws XmlPullParserException, IOException {
    if (parser.getEventType() != XmlPullParser.START_TAG) {
        throw new IllegalStateException();
    }
    int depth = 1;
    while (depth != 0) {
        switch (parser.next()) {
        case XmlPullParser.END_TAG:
            depth--;
            break;
        case XmlPullParser.START_TAG:
            depth++;
            break;
        }
    }
 }
```

工作原理：

+ 如果当前 event 不是 START_TAG将抛出异常
+ 它会消耗 START_TAG，以及包含在 END_TAG 间的事件
+ 为了确保它在正确的 END_TAG 而不是原始 START_TAG 后的第一个 tag 处停止，它将对嵌套深度进行跟踪。



​	因此，如果当前元素存在嵌套元素，depth 的值将不会为0，直到解析器消耗完原始 START_TAG 和他对应的 END_TAG 间的所有的event。



## 消耗 XML 数据

​	例子应用中使用了 AsyncTask 来获取和解析数据，当处理完成后，应用再更新主 Activity 的 UI（将解析的数据呈现到 WebView 上）。

​	loadPage() 方法做了以下工作：

+ 为 XML feed 对应的 URL 初始化一个字符串变量
+ 如果用户的设置和网络连接允许，将调用 new DownloadXmlTask().execute(url)。它将下载并解析 feed 然后将返回的字符串结果显示到 UI 上。

```java
public class NetworkActivity extends Activity {
    public static final String WIFI = "Wi-Fi";
    public static final String ANY = "Any";
    private static final String URL = "http://stackoverflow.com/feeds/tag?tagnames=android&sort=newest";

    // Whether there is a Wi-Fi connection.
    private static boolean wifiConnected = false;
    // Whether there is a mobile connection.
    private static boolean mobileConnected = false;
    // Whether the display should be refreshed.
    public static boolean refreshDisplay = true;
    public static String sPref = null;

    ...

    // Uses AsyncTask to download the XML feed from stackoverflow.com.
    public void loadPage() {

        if((sPref.equals(ANY)) && (wifiConnected || mobileConnected)) {
            new DownloadXmlTask().execute(URL);
        }
        else if ((sPref.equals(WIFI)) && (wifiConnected)) {
            new DownloadXmlTask().execute(URL);
        } else {
            // show error
        }
    }
```

DownloadXmlTask 实现了 AsyncTask 以下的方法：

+ doInBackground()：执行 loadXmlFromNetwork() 方法，它以 feed 的 URL 作为参数。loadXmlFromNetwork() 方法获取并处理 feed，完成后返回一个结果字符串。
+ onPostExecute()：处理返回的字符串并显示。

```java
// Implementation of AsyncTask used to download XML feed from stackoverflow.com.
private class DownloadXmlTask extends AsyncTask<String, Void, String> {
    @Override
    protected String doInBackground(String... urls) {
        try {
            return loadXmlFromNetwork(urls[0]);
        } catch (IOException e) {
            return getResources().getString(R.string.connection_error);
        } catch (XmlPullParserException e) {
            return getResources().getString(R.string.xml_error);
        }
    }

    @Override
    protected void onPostExecute(String result) {
        setContentView(R.layout.main);
        // Displays the HTML string in the UI via a WebView
        WebView myWebView = (WebView) findViewById(R.id.webview);
        myWebView.loadData(result, "text/html", null);
    }
}
```

 下面是 DownloadXmlTask 调用的 loadXmlFromNetwork() 方法，它做了以下工作：

1. 初始化一个 StackOverflowXmlParser。它将为包含 Entry 对象的 List 、title、url 和 summary 创建变量，来保存从 XML feed 中提取的值（事实上，title、url、summary 变量没有被使用）。
2. 调用 downloadUrl()获取 feed 并作为 InputStream 返回
3. 使用 StackOverflowXmlParser 来解析 InputStream。StackOverflowXmlParser将用从 feed 中获取的 entry 数据填充一个 List。
4. 处理 entry 的 List，并将 Feed 数据与 HTML 标记组合（最后呈现的数据是 HTML 形式）。
5. onPostExecute() 返回一个用于显示的 HTML 字符串。

```java
// Uploads XML from stackoverflow.com, parses it, and combines it with
// HTML markup. Returns HTML string.
private String loadXmlFromNetwork(String urlString) throws XmlPullParserException, IOException {
    InputStream stream = null;
    // Instantiate the parser
    StackOverflowXmlParser stackOverflowXmlParser = new StackOverflowXmlParser();
    List<Entry> entries = null;
    String title = null;
    String url = null;
    String summary = null;
    Calendar rightNow = Calendar.getInstance();
    DateFormat formatter = new SimpleDateFormat("MMM dd h:mmaa");

    // Checks whether the user set the preference to include summary text
    SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
    boolean pref = sharedPrefs.getBoolean("summaryPref", false);

    StringBuilder htmlString = new StringBuilder();
    htmlString.append("<h3>" + getResources().getString(R.string.page_title) + "</h3>");
    htmlString.append("<em>" + getResources().getString(R.string.updated) + " " +
            formatter.format(rightNow.getTime()) + "</em>");

    try {
        stream = downloadUrl(urlString);
        entries = stackOverflowXmlParser.parse(stream);
    // Makes sure that the InputStream is closed after the app is
    // finished using it.
    } finally {
        if (stream != null) {
            stream.close();
        }
     }

    // StackOverflowXmlParser returns a List (called "entries") of Entry objects.
    // Each Entry object represents a single post in the XML feed.
    // This section processes the entries list to combine each entry with HTML markup.
    // Each entry is displayed in the UI as a link that optionally includes
    // a text summary.
        for (Entry entry : entries) {
        htmlString.append("<p><a href='");
        htmlString.append(entry.link);
        htmlString.append("'>" + entry.title + "</a></p>");
        // If the user set the preference to include summary text,
        // adds it to the display.
        if (pref) {
            htmlString.append(entry.summary);
        }
    }
    return htmlString.toString();
}

// Given a string representation of a URL, sets up a connection and gets
// an input stream.
private InputStream downloadUrl(String urlString) throws IOException {
    URL url = new URL(urlString);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setReadTimeout(10000 /* milliseconds */);
    conn.setConnectTimeout(15000 /* milliseconds */);
    conn.setRequestMethod("GET");
    conn.setDoInput(true);
    // Starts the query
    conn.connect();
    return conn.getInputStream();
}
```

下面是 sample 最终显示内容的截图：

<img src="/Users/zero/OneDrive/markdown/photo/网络/NetworkUsage sample 截图.png" style="zoom:30%" />