---
title: Android 的进程和线程
tags:
  - android
date: 2017-02-21 15:37:22
categories: 笔记
---

[进程和线程](https://developer.android.com/guide/components/processes-and-threads.html)

## 进程

​	当某个应用组件启动且该应用没有运行任何其他组件时，Android系统会使用单个执行线程为应用启动新的Linux进程。默认情况下同一应用的所有组件均在相同的进程中运行，如果需要控制某个组件所属的进程则可以在AndroidManifest.xml中设置`android:process`属性，应用组件\<activity\> \<service\> \<receiver\> \<provider\>均支持此属性，此外\<application\>同样支持以设置所有组件的默认值。

> 可以通过android:process属性使不同应用的组件在相同的进程中进行，但前提是这些应用共享相同的Linux用户ID并使用了相同的证书进行签署。



### 进程生命周期

​	必要时，系统会根据“重要性层次结构”来清除重要性低的进程以回收系统资源。

​	重要性层级：

1. **前台进程**

   用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：

   + 用户正在交互的Activity运行在屏幕顶层（调用了onResume）
   + 有一个BroadcastReceiver正在运行（正在执行onReceive）
   + 有一个正在执行回调中代码的Service（Service.onCreate(),Service.onStart(),或Service.onDestroy()）
   + 托管某个 Service，后者绑定到用户正在交互的 Activity

   系统中只有少量的前台进程，杀死前台进程是内存低至无法维持这些进程运行才使用的最后手段。通常在这时候，设备已达到一个内存分页状态，所以执行这样的动作是为了使设备能够响应用户操作。

2. **可见进程**

   没有任何前台组件，但仍会影响用户在屏幕上所见内容的进程。

   + Activity可见但不在前台（已调用onPause），如前台Activity作为Dialog来显示并允许前一个Activity看起来像是在其后面。
   + Service通过使用Service.startForeground()（请求系统使用服务来让用户意识到或者本质上对用户可见）作为前台服务运行。
   + 系统用于使让用户意识到的特定功能的服务，如动态壁纸、输入法等。

   只有在为了确保所有前台进程可以正常运行时才会杀死可见进程。

3. **服务进程**

   使用startService()启动的Service。已运行较长时间（如30分钟或更久）的Service的重要性有可能被降级。

   > Services that have been running for a long time (such as 30 minutes or more) may be demoted in importance to allow their process to drop to the cached LRU list described next. This helps avoid situations where very long running services with memory leaks or other problems consume so much RAM that they prevent the system from making effective use of cached processes.

4. **缓存进程**（cached process）

   当前不需要的进程，系统将在其他地方需要内存时将其杀死。这些进程通常维护一个或多个Activity实例并且当前不可见（调用了onStop并返回）。

进程的优先级可能基于其他依赖的进程而增强。如，如果进程A使用Context.BIND_AUTO_CREATE标记来绑定一个Service或者使用进程B的ContentProvider，则进程B将至少与进程A有同等的重要性。



## 线程

​	应用启动时，系统为应用创建一个 main 线程，也称作 UI 线程。如果 UI 线程被阻塞超过 5 秒，将触发 ANR 警告。在Android 的单线程模型中有两条需要遵守的规则：

1. 不要阻塞 UI 线程
2. 不要从 UI 线程外访问 UI



### 工作线程

​	对于非即使得操作，我们需要确保它们在单独的线程(后台/工作线程)中执行。

​	Android 提供了以下从其他线程更新 UI 的几种方式：

+ Activity.runOnUiThread(Runnable)
+ View.post(Runnable)
+ View.postDelayed(Runnable, long)



​	如果操作的复杂性增加，以上几种方式可能变得复杂而难以维护。如果需要在工作线程中进行更复杂的操作，可以考虑使用 Handler 向 UI 线程传递处理消息，又或者，使用 AsyncTask 类。



#### AsyncTask 使用

​	AsyncTask 可以在工作线程上执行阻塞操作并在 UI 线程上公布结果，而不需要主动处理线程和(/或) handler。

​	AsyncTask 基本使用：子类化 AsyncTask 并实现 doInBackground() 回调方法，doInBackground() 里的操作将在后台线程中运行。如果需要更新 UI ，则需要实现 onPostExecute()，onPostExecute()运行在 UI 线程中，并处理 doInBackground() 的结果。AsyncTask 的 task 执行需要在 UI 线程中使用 execute 来启动。



### 线程安全方法

​	在某些情况下，实现的方法可能被超过一个线程调用，因此，确保线程安全是十分必要的。

​	比如，bound 服务里的方法。如果其他进程通过 IBinder 访问这些方法时，将在调用者的线程中执行。所以，IBinder 方法必须实现为线程安全方法。



## 进程间通讯IPC

​	Android 提供了一套使用 RPC(remote procedure calls) 实现 IPC(interprocess communication) 的机制——activity 或   其他应用组件调用一个方法，却是远程执行(在其他进程中)，然后再将结果返回给调用者。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。

​	要执行 IPC，应用必须使用 bindService() 绑定一个服务。





