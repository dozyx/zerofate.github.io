---
title: Android 时间更新分析
tags:
  - android
date: 2017-01-19 15:37:22
categories: 笔记
---

[Declare Inner Activity In The Android Manifest](http://stackoverflow.com/questions/3687661/declare-inner-activity-in-the-android-manifest)

[am start cannot find main activity listed in manifest]()

[Android 系统时间更新机制](http://blog.csdn.net/rjdeng/article/details/48623949)

查看Android设置中的“日期和时间”，可以看到功能实现主要在DateTimeSettings类中，它是一个Fragment，其Activity的声明为

```xml
<activity android:name="Settings$DateTimeSettingsActivity"
                android:label="@string/date_and_time"
                android:taskAffinity="">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <action android:name="android.settings.DATE_SETTINGS" />
                <action android:name="android.intent.action.QUICK_CLOCK" />
                <category android:name="android.intent.category.VOICE_LAUNCH" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
            <meta-data android:name="com.android.settings.FRAGMENT_CLASS"
                android:value="com.android.settings.DateTimeSettings" />
            <meta-data android:name="com.android.settings.TOP_LEVEL_HEADER_ID"
                android:resource="@id/date_time_settings" />
            <meta-data android:name="com.android.settings.PRIMARY_PROFILE_CONTROLLED"
                android:value="true" />
        </activity>
```

`Settings$DateTimeSettingsActivity`表示声明的Activity是Settings的一个内部类

> 如果想要通过adb shell命令启动inner activity，需要在$前添加反斜杠，如
>
> am start -n com.android.settings/.Settings\\$DateTimeSettingsActivity



### 自动更新时间

#### 检测

`Settings.Global.getInt(getContentResolver(), Settings.Global.AUTO_TIME)`

#### 设置

`Settings.Global.putInt(getContentResolver(), Settings.Global.AUTO_TIME, autoEnabled ? 1 : 0);`

#### 启用自动更新

自动更新位于NetworkTimeUpdateService类(该类并不继承Service)，其介绍

> 监测网络时间，并在系统时间未进行同步并且最近没有任何的NITZ(Network Identity and Time Zone，是一种用于自动配置本地的时间和日期的机制，同时也通过无线网向移动设备提供运营商信息)更新时刷新时间。如果查找网络时间失败，将进行几次短间隔的尝试，然后经过一段较长时间后再进行复位检测。
>
> 如果用户启动了自动更新时间选项，在NITZ不可用时将会立即检查网络时间。

NetworkTimeUpdateService通过SettingsObserver(继承ContentObserver)来监测Settings.Global.AUTO_TIME的改变，在发生改变后将在onPollNetworkTime中处理

> 从源码中可以看到，在我们点击开启自动更新时，并不会立即从网络获取更新，而是会判断mPollingIntervalMs，当上一次更新超过该间隔才会再次从网络更新。进一步查看CdmaServiceStateTracker和GsmServiceStateTracker类，这两个类也对Settings.Global.AUTO_TIME进行了监听，当启动自动更新时会调用revertToNitzTime方法，该方法将会根据上一次保存的时间进行计算来得到当前时间。因此，会出现未连接任何网络，时间却会自动更新的现象。

```java
    private void onPollNetworkTime(int event) {
        // 不是自动更新不需要处理
        if (!isAutomaticTimeRequested()) return;

        final long refTime = SystemClock.elapsedRealtime();
        // If NITZ time was received less than mPollingIntervalMs time ago,
        // no need to sync to NTP.
      	// 如果距离上次更新时间未超过指定的间隔则不需要更新
      	// mPollingIntervalMs默认为86400000(24小时),从\frameworks\base\core\res\res\values\config.xml读取
      	// mNitzTimeSetTime保存的是网络更新时的时间（通常为nitz）
        if (mNitzTimeSetTime != NOT_SET && refTime - mNitzTimeSetTime < mPollingIntervalMs) {
            resetAlarm(mPollingIntervalMs);//重设下一次网络更新的时间
            return;
        }
        final long currentTime = System.currentTimeMillis();
        if (DBG) Log.d(TAG, "System time = " + currentTime);
        // Get the NTP time
        if (mLastNtpFetchTime == NOT_SET || refTime >= mLastNtpFetchTime + mPollingIntervalMs
                || event == EVENT_AUTO_TIME_CHANGED) {
            if (DBG) Log.d(TAG, "Before Ntp fetch");

            // force refresh NTP cache when outdated
            if (mTime.getCacheAge() >= mPollingIntervalMs) {
                mTime.forceRefresh();
            }

            // only update when NTP time is fresh
            if (mTime.getCacheAge() < mPollingIntervalMs) {
                final long ntp = mTime.currentTimeMillis();
                mTryAgainCounter = 0;
                // If the clock is more than N seconds off or this is the first time it's been
                // fetched since boot, set the current time.
              	// mTimeErrorThresholdMs默认为5000，误差超过该值或第一次获取ntp才进行更新
                if (Math.abs(ntp - currentTime) > mTimeErrorThresholdMs
                        || mLastNtpFetchTime == NOT_SET) {
                    // Set the system time
                    if (DBG && mLastNtpFetchTime == NOT_SET
                            && Math.abs(ntp - currentTime) <= mTimeErrorThresholdMs) {
                        Log.d(TAG, "For initial setup, rtc = " + currentTime);
                    }
                    if (DBG) Log.d(TAG, "Ntp time to be set = " + ntp);
                    // Make sure we don't overflow, since it's going to be converted to an int
                  	//将系统时间设置为获取的ntp时间
                    if (ntp / 1000 < Integer.MAX_VALUE) {
                        SystemClock.setCurrentTimeMillis(ntp);
                    }
                } else {
                    if (DBG) Log.d(TAG, "Ntp time is close enough = " + ntp);
                }
                mLastNtpFetchTime = SystemClock.elapsedRealtime();
            } else {
                // Try again shortly
              	// 短时间内多次获取更新时间
              	//nTryAgainTimesMax默认3，mPollingIntervalShorterMs
                mTryAgainCounter++;
                if (mTryAgainTimesMax < 0 || mTryAgainCounter <= mTryAgainTimesMax) {
                    resetAlarm(mPollingIntervalShorterMs);
                } else {
                    // Try much later
                    mTryAgainCounter = 0;
                    resetAlarm(mPollingIntervalMs);
                }
                return;
            }
        }
        resetAlarm(mPollingIntervalMs);
    }
```





### 获取时间API类型

#### SystemClock.elapsedRealtime

从设备启动经过的时间，包括睡眠时间，单位为ms

#### System.currentTimeMillis

获取自January 1, 1970 00:00:00.0 UTC至今的时间，单位ms



### NITZ和NTP

[NITZ wiki](https://en.wikipedia.org/wiki/NITZ)

[NITZ 百度百科](http://baike.baidu.com/link?url=iHw4z-tpmAlGhXgF21p-iPHV4PiQGYT2iD0ZkrwgC2o5iH6FLollzWYyelWvF858L2rstPXlZPvLgjfghGrC_q)

[NTP wiki](https://en.wikipedia.org/wiki/Network_Time_Protocol)

[NTP 百度百科](http://baike.baidu.com/link?url=cpYVMZper1JPATQT_VfEp9ZsWFq5aCBJdhdh2zU_AS0ZBhlA6u7tWn2uoj7qPJukesl70IoWwhNnzvJ0rJHkyq)

[nitz和ntp协议](http://wenku.baidu.com/link?url=gBAU28xQV1d39yJYiUINkw5ggKHMo1xWytW1GWNt8VQxo46FAXkGzHqLGZR5GkKEqpAxivcg4QOF-M5VIQLPcKf0IssftyoFpvERcW_rMhe)

Android通过网络同步时间有两种方式：NITZ和NTP。设置自动更新时间后，android会先尝试NITZ	方式，若获取时间失败，则使用NTP方式。

> NITZ是一种GSM/WCDMA基地台方式，必须插入SIM卡，且需要operator支持；可以提供时间和时区信息.中国大陆运营商基本是不支持的。
>
> NTP在无SIM卡或operator不支持NITZ时使用，单纯通过网络（GPRS/WIFI）获取时间，只提供时间信息，没有时区信息（因此在不支持NITZ的地区，自动获取时区功能实际上是无效的）。
>
> NTP还有一种缓存机制：当前成功获取的时间会保存下来，当用户下次开启自动更新时间功能时会结合手机clock来进行时间更新。这也是没有任何网络时手机却能自动更新时间的原因。

#### NITZ

Network Identity and Time Zone，是一种用于自动配置本地的时间和日期的机制，同时也通过无线网向移动设备提供运营商信息。NITZ是GSM的可选功能，通常用于更新移动电话的系统时间。

#### NTP

Network Time Protocol，用来同步网络中各个计算机的时间的协议。计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，以选择最佳的路径和来源以便校正主机时间。



### 广播

时间相关广播有：

> //每分钟发送一次(秒数为00)
>
> **public static final String ACTION_TIME_TICK = "android.intent.action.TIME_TICK";**
>
> //时间被设置时发送，通过打印可以看到在00、10、20、30、40、50、51、52...59时都会发送
>
> **public static final String ACTION_TIME_CHANGED = "android.intent.action.TIME_SET";**
>
> **public static final String ACTION_TIMEZONE_CHANGED = "android.intent.action.TIMEZONE_CHANGED";**
>
> **public static final String ACTION_DATE_CHANGED = "android.intent.action.DATE_CHANGED";**

### 部分术语

#### DST

[DST wiki](https://en.wikipedia.org/wiki/Daylight_saving_time)

[DST 百度百科](http://baike.baidu.com/link?url=xRfYZJTG0vDytLJpQTvtcw97UcD89HebBGFJ0EsLJVlWKpR0PK6z-A7cm3hgMKkv2KE1QY7nPV8Qn0-Q0D7rQq)

Daylight saving time，阳光节约时，即夏令制，我国曾在1986~1992年实施DST。所谓的DST，就是利用夏季天亮得早这一自然现象，人为地将时间提前一小时。





















