---
title: volatile 关键字
tags:
  -  java
date: 2017-05-04 15:37:22
categories: 笔记
---

[Java Volatile Keyword](http://tutorials.jenkov.com/java-concurrency/volatile.html)

[volatile 百度百科](http://baike.baidu.com/link?url=2cwEUsbe2-5Vzfz5xX1LkjNBmp9bWa3T3DyxQuMI_06WwYSPkd2Ndp26j9ODcYwEdn0cL1FUK-n-O-G-z2wEO9UHrH0RcZCpOZHjia9LG6G)

> ​	以下内容和图片大部分来自 Jenkov 博文《Java Volatile Keyword》。

​	volatile 关键字用来将一个变量标记为“在主存中存储”，更准确的说，是每一次 volatile 变量的读写都是通过计算机的主存，而不是CPU缓存（个人理解似乎是依然会保存到CPU缓存，只是每一次都会与主存同步）。事实上，从 Java 5起，volatile 关键字不仅仅只是确保通过主存读写变量。

​	volatile可以确保本指令不会进行编译器的优化。

​	

### 可见性保证

​	volatile 确保多个线程间对变量的改变是可见的。

​	在一个多线程应用中，线程对非volatile变量进行操作时，每一个线程都可能处于性能原因而将变量从主存复制到CPU缓存中。假如计算机有两个CPU，线程运行在不同CPU上：

​	![java-volatile-1](https://ws1.sinaimg.cn/large/006tKfTcgy1finymzue67j30dy0brjry.jpg)

想象以下场景：Thread 1 改变了counter变量，但Thread 1 和 Thread 2可能不定时读取 counter 变量。

如果 counter 不是 volatile，这将无法保证 counter的值在何时从 CPU 缓存写回主存中，也就意味着CPU 缓存和主存中的 counter 变量值可能是不一样的。情况如下：

![java-volatile-2](https://ws4.sinaimg.cn/large/006tKfTcgy1finyn0u3sqj30d00b9gmb.jpg)

上述的情况称为“可见性”问题，一个线程的更新对其他线程并不可见。通过将 counter 声明为 volatile，对counter 的写操作会立即写回主存。同时，所有对 counter 的读操作也会直接从主存中读取。



### Happens-Before 保证

+ 如果Thread A 对一个volatile 变量进行写操作，Thread B随后读取同一个 volatile 变量，那么，Thread A 写 volatile变量之前的所有对 A 可见的变量，也会在 Thread B读取 volatile 变量后对 B 可见
+ **对 volatile 变量的读和写指令不会被 JVM 重排序**（出于性能原因）。指令前和后的指令可以被重排序，但volatile变量的读或写不会与这些指令混合。

更深入的解释：

​	当一个线程写一个volatile变量时，其他被线程修改的在volatile变量前的变量也会被刷新到主存；当一个线程读一个 volatile 变量时，也会读取所有随 volatile 变量刷新到主存中的变量。

示例：

```java
Thread A:
    sharedObject.nonVolatile = 123;
    sharedObject.counter     = sharedObject.counter + 1;

Thread B:
    int counter     = sharedObject.counter;
    int nonVolatile = sharedObject.nonVolatile;
```

当 Thread A  写 volatile 变量 sharedObject.counter 时，sharedObject.nonVolatile 和 sharedObject.counter 都会写到主存。

当 Thread B 读 sharedObject.counter 时，sharedObject.counter 和 sharedObject.nonVolatile都会从主存读到 CPU 缓存。Thread B 读 sharedObject.nonVolatile 时将看到 Thread A 的修改。

开发者可以利用这种延伸的可见性保证来优化线程间变量的可见性，只需要声明一个或几个volatile变量，而不是将每一个变量都进行声明。

例子：

```java
public class Exchanger {

    private Object   object       = null;
    private volatile hasNewObject = false;

    public void put(Object newObject) {
        while(hasNewObject) {
            //wait - do not overwrite existing new object
        }
        object = newObject;
        hasNewObject = true; //volatile write
    }

    public Object take(){
        while(!hasNewObject){ //volatile read
            //wait - don't take old object (or null)
        }
        Object obj = object;
        hasNewObject = false; //volatile write
        return obj;
    }
}
```

Thread A 不时调用 put()来放置 objects，Thread B	不时通过 take() 来获取objects。该Exchanger 在Thread A 只调用 put() 和 Thread B 只调用 take() 时工作良好。

 假如，JVM将指令重排序，则会出现以下情况：

```java
while(hasNewObject) {
    //wait - do not overwrite existing new object
}
hasNewObject = true; //volatile write
object = newObject;
```

hasNewObject 的写操作在新的object 实际设置前发生，这样就会影响到 object 的可见性。为避免这种情况，volatile 附带了“happens before guarantee”。



### 什么时候volatile是足够的

![java-volatile-3](https://ws2.sinaimg.cn/large/006tKfTcgy1finyn0cfo5j30cx0b8gma.jpg)

场景：Thread 1 读取 counter 的值0，并存入 CPU 缓存，将 counter 加1，但未写回主存；Thread 2 同样操作。这样 Thread 1 和 Thread 2 就变得不同步。counter 本该变为2，但 CPU 缓存中为1，而主存中为0。及时线程最后将值写会主存，仍然会错误。

​	因此，如果有两个线程同时对同一共享变量进行读写，volatile 关键字并不能保证正常运行。



### volatile 性能

​	从主存中进行读写会比CPU缓存更高昂，但避免指令重排序可以增强性能。因此，只有在真正需要确保变量可见性时才使用volatile变量。



























