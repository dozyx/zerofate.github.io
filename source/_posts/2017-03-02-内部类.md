---
title: 内部类
tags:
  - java
date: 2017-03-02 15:37:22
categories: 笔记
---

​	[Nested Classes](http://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)

​	内部类，Nested Classes

​	形式：

```java
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
```

​	内部类有两类：静态、非静态

```java
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
```

​	内部类是封闭类(enclosing class)的成员。非静态内部类可以访问封闭类的其他成员，即使他们被声明为private。**静态内部类无法访问封闭类中的其他成员**。作为OuterClass的一个成员，内部类可以声明为private，public，protected或者包级私有（外部类只能声明为public或包级私有）。



### 为什么使用内部类

+ 逻辑上对仅在一处使用的类进行组合；

+ 增强封装性

  如顶层类A和B，B需要访问A的私有成员，这会造成困扰。通过将B隐藏在类A中，A中的私有成员就可以被B访问，并且B也可以与外部世界隔离。

+ 使代码变得更可读和便于维护。

  因为顶层类中的小型内部类被放置在靠近使用它的地方。



### 静态内部类Static Nested Classes

​	与类的静态方法一样，静态内部类无法直接指向定义在封闭类中的实例变量和方法——只能通过对象的引用。

> 静态内部类与外部类的实例成员的交互类似于其他的顶级类。事实上，静态内部类表现得就像一个为了包装方便而内嵌在另一个顶级类中的顶级类。

​	静态内部类通过封闭类类名进行访问

​	`OuterClass.StaticNestedClass`

​	如：

```java
OuterClass.StaticNestedClass nestedObject =
     new OuterClass.StaticNestedClass();
```



### 内部类Inner Classes

+ Inner class可以访问封闭类对象的方法和字段
+ 由于内部类与一个实例相关联，内部类不能定义自己的静态成员

```java
class OuterClass {
    ...
    class InnerClass {
        ...
    }
}
```

​	InnerClass的实例只能存在于外部类的实例中，并且可以直接访问它的封闭实例的方法和字段。

​	实例化一个内部类，必须先实例化外部类，然后按照以下语法来在外部对象中创建内部对象：

​	`OuterClass.InnerClass innerObject = outerObject.new InnerClass();`

[local classes](http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html)和[anonymous classes](http://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)是两种特殊形式的内部类。



### 序列化Serialization

> 强烈反对序列化内部类。



### 总结

实例化：

+ 静态内部类

  `OuterClass.StaticNestedClass nestedObject =new OuterClass.StaticNestedClass();`

+ 内部类

  `OuterClass.InnerClass innerObject = outerObject.new InnerClass();`

区别：

+ 静态内部类无法直接访问外部类成员
+ 非静态内部类无法定义自己的静态成员
+ **静态内部类事实上相当于一个顶级类，只是内嵌在了一个顶层类中**
+ 非静态内部类（包括匿名内部类）默认持有对外部类的引用





