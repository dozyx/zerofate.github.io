---
title: API Guides - Loader 的使用
tags:
  - android
date: 2017-03-13 15:37:22
categories: 笔记
---

​	[Loader Guides](https://developer.android.com/guide/components/loaders.html#summary)

​	[Loader](https://developer.android.com/reference/android/content/Loader.html)	

java.lang.Object
   ↳	android.content.Loader<D>
  Known Direct Subclasses
AsyncTaskLoader<D>
  Known Indirect Subclasses
CursorLoader

------

​	Android 3.0 中引入了Loader，Loader可以在Activity或者Fragment中用于从content provider或者其他数据源中加载数据。不使用Loader时可能遇到的问题：

+ 如果直接在activity或者fragment中获取数据，将导致程序响应慢
+ 如果在其他线程（可能是在AsyncTask）中获取数据，这就要求在activity或者fragment的生命周期中同时负责管理该线程和UI线程，比如在onDestroy()和配置改变的时候。



​	**优势：**

+ 运行在单独的线程中，这样可以避免无响应
+ 事件发生时可以通过回调方法来简单地进行线程管理
+ Loader可以在配置改变时保留和缓存结果来避免重复查询
+ Loader可以通过实现一个observer来监视底层数据源的改变。如，CursorLoader自动注册一个ContentObserver在数据变化时自动重加载。



## 文档说明

​	Loader类用于异步加载数据，当Loader处于active状态时，它需要监视数据源并在内容发生改变时发送新的结果。

​	线程注意项：loader客户端应当将从主线程中执行Loader的所有调用作为一条准则。Loader的子类（如AsyncTaskLoader）通常在单独的线程中进行工作，但提供结果时还是在主线程中完成。

​	子类一般要实现至少以下几个方法： onStartLoading(), onStopLoading(), onForceLoad(), 和 onReset()

## Loader的基本API

+ LoaderManager

  + 与Activity或Fragment关联的一个抽象类，用于管理一个或多个Loader实例。
  + 每个activity或fragment只有一个LoaderManager，但一个LoaderManager可以管理多个loader。
  + 从activity或fragment中通过getLoaderManager来获得LoaderManager。
  + 调用initLoader()或restartLoader()来开始从loader中加载数据，系统会自动判断相同整型id的loader是否已存在，从而确定是创建一个新的loader还是复用已存在的loader。

+ LoaderManager.LoaderCallbacks

  loader事件发生时的回调接口，该接口定义了三个回调方法：

  + onCreateLoader(int, Bundle) 系统需要创建新的loader时调用，需要在此处创建一个Loader对象并将其返回给系统。
  + onLoadFinished(Loader\<D\>, D) 当loader完成数据加载时调用，通常此处代码用于将数据显示给用户。
  + onLoaderReset(Loader\<D\>) 先前创建的loader被重置时调用（调用了destroyLoad(int)或当activity或fragment被销毁时），此时的数据将变得不可用。此处的代码需要移除所有对该loader数据的引用。

+ Loader

  Loader用于完成数据的加载。



## 在应用中使用Loader（API Guide）

​	示例主要包括以下几部分：

+ 一个Activity或Fragment
+ 一个LoaderManager实例
+ 一个加载ContentProvider中数据的CursorLoader。除此之外，还可以实现自己的Loader子类或AsyncTaskLoader来加载其他源的数据
+ 一个LoaderManager.LoaderCallbacks实现
+ 一个显示loader数据的方式，如SimpleCursorAdapter
+ 一个数据源，如使用CursorLoader时的ContentProvider



### 开始一个Loader

​	通常在activity的onCreate()方法或者fragment的onActivityCreated()方法中对Loader进行初始化，如

```java
// Prepare the loader.  Either re-connect with an existing one,
// or start a new one.
getLoaderManager().initLoader(0, null, this);
```

`initLoader()`方法接收如下参数：

+ 一个标识该loader的唯一id
+ 用于在构造时就提供loader的可选参数
+ LoaderManager.LoaderCallbacks接口

> 注意：initLoader()方法返回其创建的Loader，但我们并不需要获取它的引用。LoaderManager会自动管理loader的存活。大部分情况下，我们在加载过程中通过LoaderManager.LoaderCallbacks干预而不是直接与loader进行交互。



### 重新开始一个Loader

​	使用 restartLoader() 废弃旧的数据，并重新开始。如：

```java
public boolean onQueryTextChanged(String newText) {
    // Called when the action bar search text has changed.  Update
    // the search filter, and restart the loader to do a new query
    // with this filter.
    mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
    getLoaderManager().restartLoader(0, null, this);
    return true;
}
```



### LoaderManager回调的使用

​	LoaderManager.LoaderCallbacks是客户端与LoaderManager交互的回调接口，其包括以下方法：

+ onCreateLoader()

  实例化并返回一个给定ID的新的Loader

+ onLoadFinished()

  先前创建的loader结束加载时调用

+ onLoadRest()

  先前创建的loader被重置时调用，数据将变得不可用



#### onCreateLoader

​	当访问loader，如通过initLoader()时，将检查loader的ID是否已存在，如果不存在将触发onCreateLoader()回调。

​	本例中，onCreateLoader回调中将创建一个CursorLoader，我们使用CursorLoader的构造方法来创建并提供查询所需要的完整信息：

+ uri：需要获取的内容的URI
+ projection：需要返回的列。传入null将返回所有列，这样是很低效的。
+ selection：用于过滤哪些行需要返回，当作SQL WHERE语句进行格式化。null将返回给定URI的所有行。
+ selectionArgs：selection中的`?`将被selectionArgs的值所替换。
+ sortOrder：如何排列行，作为SQL ORDER BY语句进行格式化。null将使用默认排序，将可能为无序。



示例代码：

```java
// If non-null, this is the current filter the user has provided.
String mCurFilter;
...
public Loader<Cursor> onCreateLoader(int id, Bundle args) {
    // This is called when a new Loader needs to be created.  This
    // sample only has one Loader, so we don't care about the ID.
    // First, pick the base URI to use depending on whether we are
    // currently filtering.
    Uri baseUri;
    if (mCurFilter != null) {
        baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
                  Uri.encode(mCurFilter));
    } else {
        baseUri = Contacts.CONTENT_URI;
    }

    // Now create and return a CursorLoader that will take care of
    // creating a Cursor for the data being displayed.
    String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
            + Contacts.HAS_PHONE_NUMBER + "=1) AND ("
            + Contacts.DISPLAY_NAME + " != '' ))";
    return new CursorLoader(getActivity(), baseUri,
            CONTACTS_SUMMARY_PROJECTION, select, null,
            Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC");
}

```



#### onLoadFinished

​	在这里需要移除旧的数据，但不应该主动释放数据，因为这些数据属于loader并且loader会处理它们。

​	如，数据是来自CursorLoader的cursor，我们不应该主动调用close()。如果cursor放置在CursorAdapter中，应使用swapCursor()方法。

```java
// This is the Adapter being used to display the list's data.
SimpleCursorAdapter mAdapter;
...

public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
    // Swap the new cursor in.  (The framework will take care of closing the
    // old cursor once we return.)
    mAdapter.swapCursor(data);
}
```



#### onLoaderReset

​	数据将被释放，因此我们需要将其引用移除。

```java
// This is the Adapter being used to display the list's data.
SimpleCursorAdapter mAdapter;
...

public void onLoaderReset(Loader<Cursor> loader) {
    // This is called when the last Cursor provided to onLoadFinished()
    // above is about to be closed.  We need to make sure we are no
    // longer using it.
    mAdapter.swapCursor(null);
}
```























